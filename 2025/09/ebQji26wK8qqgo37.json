{
  "active": false,
  "connections": {
    "When chat message received": {
      "main": [
        [
          {
            "node": "ChatInput",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding": {
      "main": [
        [
          {
            "node": "Semantic Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VLLM": {
      "ai_languageModel": [
        [
          {
            "node": "Generate Response",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "PreparePrompts": {
      "main": [
        [
          {
            "node": "Generate Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare output": {
      "main": [
        [
          {
            "node": "PreparePrompts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VLLM1": {
      "ai_languageModel": [
        []
      ]
    },
    "Semantic Query": {
      "main": [
        [
          {
            "node": "Format Documents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Rerank Query": {
      "main": [
        [
          {
            "node": "Rerank - Qwen3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Full Resource Info": {
      "main": [
        [
          {
            "node": "Prepare output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Knobs": {
      "main": [
        [
          {
            "node": "Create JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PreparePrompts - Knobs": {
      "main": [
        [
          {
            "node": "Prepare Knobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Knobs Formated": {
      "main": [
        [
          {
            "node": "Generate Reranking Instructions - Soft Prio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Reranking Instructions - Soft Prio": {
      "main": [
        [
          {
            "node": "Generate Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Documents": {
      "main": [
        [
          {
            "node": "Create Rerank Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rerank - Qwen3": {
      "main": [
        [
          {
            "node": "Get Full Resource Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ChatInput": {
      "main": [
        [
          {
            "node": "PreparePrompts - Knobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create JSON": {
      "main": [
        [
          {
            "node": "Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query": {
      "main": [
        [
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute a SQL query": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Generate Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VLLM2": {
      "ai_languageModel": [
        [
          {
            "node": "Generate Response1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        []
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Prepare Knobs",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-09-15T12:34:50.446Z",
  "id": "ebQji26wK8qqgo37",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "Resourcing Query",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        -3696,
        272
      ],
      "id": "5dffec22-d7e3-4ecc-98c0-5e022fd5a86d",
      "name": "When chat message received",
      "webhookId": "4c1b54ba-d7f3-4459-a20d-e6827cc0df32"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.70:11434/api/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "nomic-embed-text"
            },
            {
              "name": "prompt",
              "value": "={{ $json.finalQuery }}"
            }
          ]
        },
        "options": {}
      },
      "id": "e6daa1ec-d781-4383-9ec9-805ccadc092e",
      "name": "Generate Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -1184,
        -256
      ]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "qwen3-coder-30b-32k",
          "mode": "list",
          "cachedResultName": "qwen3-coder-30b-32k"
        },
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -128,
        208
      ],
      "id": "a1cb9c15-3537-41c2-ba86-788235396b92",
      "name": "VLLM",
      "credentials": {
        "openAiApi": {
          "id": "09tIxrZPXx1gwPgx",
          "name": "vllm"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const chatInput = $('When chat message received').first().json.chatInput\nconst contextForPrompt = $input.first().json.llm_context\n\nconst systemPrompt = \"You are an AI assistant that helps pick employees for tasks and projects. Use ONLY the candidate snippets provided below.  Do NOT invent skills or industries. If a candidate clearly misses a must-have, you may omit them. Return a concise, useful answer.\";\n\n// 3. Define the user prompt\nconst userPrompt = `USER REQUEST:\n${chatInput}\n\nINSTRUCTIONS: $('Generate Reranking Instructions - Soft Prio').first().json.instruction\n\nFORMAT:\n- For each included candidate, show:\n  • name (required)\n  id\n  employment_type\n  • role/section and seniority (if present in the snippet)\n  • 2–4 directly relevant skills/tech terms mentioned in the snippet\n  • 1–2 relevant industries/domains from the snippet that match the request\n  • A 2-3 line rationale grounded in the snippet (quote short phrases if helpful)\n- Prefer 3–5 candidates unless fewer obviously match.\n- If none match the must-haves, say so briefly.\nProvide a short paragraph summary, then a bullet list of candidates. If there no valid candidates, do not show them.\n\nCANDIDATE SNIPPETS:\n${contextForPrompt}\n`;\n\nreturn {\n  json: {\n    userPrompt,\n    systemPrompt: systemPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        16
      ],
      "id": "e81a740f-f543-46ab-8bdd-bfdfc81706ec",
      "name": "PreparePrompts"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Function node: Build LLM-friendly context from selected profiles\n *\n * INPUT (items): an array where each item looks like:\n *   {\n *     json: {\n *       profile: { json: { id, name, industry, description, skills_senior, ... , embedding_facts_text, similarity } },\n *       relevance_score?: number, // optional (from reranker)\n *       score?: number            // optional alias\n *     }\n *   }\n *\n * OUTPUT (one item):\n *   {\n *     json: {\n *       llm_context: \"CONTEXT_START\\n...\\nCONTEXT_END\",\n *       candidates: [ ... ] // optional structured echo for debugging or downstream use\n *     }\n *   }\n */\n\nconst MAX_DESC_CHARS = 450; // keep it concise for prompts\nconst MAX_SKILLS = 10;      // limit skills to avoid prompt bloat\n\nfunction collapse(s) {\n  return (s ?? \"\").toString().replace(/\\s+/g, \" \").trim();\n}\n\nfunction truncate(s, n) {\n  s = collapse(s);\n  return s.length > n ? s.slice(0, n - 1) + \"…\" : s;\n}\n\nfunction normSeniority(s) {\n  const t = collapse(s);\n  // Normalize variants like \"Senior 1/2/3\" → \"Senior\"\n  const senior = t.replace(/Senior\\s*\\d+/i, \"Senior\");\n  // You can add more mappings if needed (e.g., \"Med 2\" → \"Mid\")\n  return senior;\n}\n\nfunction listify(csv, limit = Infinity) {\n  const arr = collapse(csv)\n    .split(/\\s*,\\s*/)\n    .filter(Boolean);\n  return limit === Infinity ? arr : arr.slice(0, limit);\n}\n\nfunction uniq(arr) {\n  const seen = new Set();\n  const out = [];\n  for (const v of arr) {\n    const key = v.toLowerCase();\n    if (!seen.has(key)) {\n      seen.add(key);\n      out.push(v);\n    }\n  }\n  return out;\n}\n\nconst items = $input.all();\n\n// Build candidate blocks\nconst blocks = [];\nconst structured = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const root = items[i]?.json ?? {};\n  // Support both shapes: profile.json or plain object\n  const p = root.profile?.json ?? root;\n\n  const id = collapse(p.id);\n  const name = collapse(p.name);\n  const section = collapse(p.section); // e.g., \"SA\" or \"Backend - Python\"\n  const seniority = normSeniority(p.seniority);\n  const employment = collapse(p.employment_type);\n  const industries = listify(p.industry);\n  const skillsSenior = listify(p.skills_senior, MAX_SKILLS);\n  const skillsMedium = listify(p.skills_medium, MAX_SKILLS);\n  const skillsJunior = listify(p.skills_junior, MAX_SKILLS);\n  const skills = uniq([...skillsSenior, ...skillsMedium, ...skillsJunior]).slice(0, MAX_SKILLS);\n\n  const facts = collapse(p.embedding_facts_text);\n  const similarity = p.similarity != null ? Number(p.similarity) : undefined;\n  const rerankScore = root.relevance_score != null ? Number(root.relevance_score)\n                    : (root.score != null ? Number(root.score) : undefined);\n\n  // Keep description short but useful\n  const description = truncate(p.description || p.embedding_convo_text || \"\", MAX_DESC_CHARS);\n\n  // Build a concise, LLM-friendly block\n  const lines = [];\n  lines.push(`Candidate ${i + 1}: ${name} (ID: ${id})`);\n  if (section || seniority || employment) {\n    const parts = [];\n    if (section) parts.push(`Role/Section: ${section}`);\n    if (seniority) parts.push(`Seniority: ${seniority}`);\n    if (employment) parts.push(`Employment: ${employment}`);\n    lines.push(parts.join(\" | \"));\n  }\n  if (skills.length) {\n    lines.push(`Skills: ${skills.join(\"; \")}`);\n  }\n  if (industries.length) {\n    lines.push(`Industries: ${industries.join(\"; \")}`);\n  }\n  if (description) {\n    lines.push(`Summary: ${description}`);\n  }\n  if (facts) {\n    lines.push(`Facts: ${facts}`);\n  }\n  const signals = [];\n  if (typeof rerankScore === \"number\") signals.push(`rerank=${rerankScore.toFixed(3)}`);\n  if (typeof similarity === \"number\") signals.push(`similarity=${similarity.toFixed(3)}`);\n  if (signals.length) {\n    lines.push(`Signals: ${signals.join(\" | \")}`);\n  }\n\n  blocks.push(lines.join(\"\\n\"));\n\n  structured.push({\n    id,\n    name,\n    section,\n    seniority,\n    employment_type: employment,\n    industries,\n    skills,\n    description,\n    facts,\n    similarity,\n    rerank_score: rerankScore,\n  });\n}\n\n// Final context string\nconst llmContext = `CONTEXT_START\n${blocks.join(\"\\n\\n\")}\nCONTEXT_END`;\n\nreturn [\n  {\n    json: {\n      llm_context: llmContext,\n      candidates: structured, // optional; helpful for debugging or UI\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -576,
        16
      ],
      "id": "63de61f2-c756-46f3-bf60-2110cd0dd5fb",
      "name": "Prepare output"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "qwen3-coder-30b-32k",
          "mode": "list",
          "cachedResultName": "qwen3-coder-30b-32k"
        },
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -3152,
        480
      ],
      "id": "02690d5c-6ec0-4dd5-8dda-ea9ebcb1308a",
      "name": "VLLM1",
      "credentials": {
        "openAiApi": {
          "id": "09tIxrZPXx1gwPgx",
          "name": "vllm"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.userPrompt }}",
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.systemPrompt }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -128,
        16
      ],
      "id": "39d9d9a4-ef85-41ae-b453-99170ec54955",
      "name": "Generate Response"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://192.168.20.70:8443/rest/v1/rpc/match_ganttic_resources",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "query_embedding",
              "value": "={{ $json.embedding }}"
            },
            {
              "name": "similarity_threshold",
              "value": "0.3"
            },
            {
              "name": "match_count",
              "value": "50"
            }
          ]
        },
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -880,
        -256
      ],
      "id": "c13c5a96-1cf4-49fc-a968-9ce8802e71fb",
      "name": "Semantic Query",
      "credentials": {
        "supabaseApi": {
          "id": "Vbtfas1bVCzZ2Wde",
          "name": "Supabase account 2"
        }
      }
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"model\": \"tomaarsen/Qwen3-Reranker-4B-seq-cls\",\n  \"query\": {{ JSON.stringify($('Generate Reranking Instructions - Soft Prio').first().json.formattedQuery) }},\n  \"documents\": {{ JSON.stringify($json.formattedDocuments) }},\n  \"top_n\": 10\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1312,
        16
      ],
      "id": "3e13f8d2-a7bd-4306-b0e2-079221c7dd18",
      "name": "Create Rerank Query"
    },
    {
      "parameters": {
        "jsCode": "// Rerank results\nconst rerank = $input.first().json.results || [];\n\n// Original items array from a previous node (50 full profiles)\nconst originalItems = $('Semantic Query').all()\n// allProfiles should be an array of objects matching the positions in documents[].\n\n// Build enriched list\nconst output = rerank.map(r => {\n  const idx = r.index;\n  const profile = originalItems[idx]; // original full data object\n  return {\n    profile\n  };\n  // return {\n  //   json: {\n  //     id:               profile.json.id,\n  //     name:             profile.json.name,\n  //     industry:         profile.json.industry,\n  //     section:          profile.json.section,\n  //     seniority:        profile.json.seniority,\n  //     employment_type:  profile.json.employment_type,\n  //     skills_senior:    profile.json.skills_senior,\n  //     skills_medium:    profile.json.skills_medium,\n  //     skills_junior:    profile.json.skills_junior,\n  //     embedding_facts_text: profile.json.embedding_facts_text,\n  //     relevance_score:  r.relevance_score\n  //   }\n  // };\n});\n\n// Only return top N (rerank is already sorted)\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        16
      ],
      "id": "d14fc147-a00c-4121-9604-fb062dc5d702",
      "name": "Get Full Resource Info"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.userPrompt }}",
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.systemPrompt }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -3056,
        272
      ],
      "id": "571db1b5-1dd0-449b-a9dc-879bf9b05432",
      "name": "Prepare Knobs"
    },
    {
      "parameters": {
        "jsCode": "const chatInput = $input.first().json.chatInput;\n\nconst systemPrompt = \"Extract staffing constraints from the user's request. Be strict and literal.Return ONLY compact JSON, no prose.\";\n\n// 3. Define the user prompt\nconst userPrompt = `TEXT:\n${chatInput}\n\nUse Supabase Tool to retrieve best candidates.\nGiven the \"role, job title\" map it to the most appropriate role name from the following list:\n\nAVAILABLE ROLES (use EXACTLY as written):\n- Node.js Engineer\n- Solution Architect\n- .NET Engineer\n- UI/UX Designer\n- PHP Engineer\n- Data Expert\n- Program manager\n- Manager of Frontend Excellence\n- Python Engineer\n- React Engineer\n- Java Engineer\n- Product owner\n- Angular Engineer\n- Ruby Engineer\n- Vue.js Engineer\n- Data Engineer\n- Mobile Engineer\n- Manager of Design Excellence\n- WordPress Engineer\n- QA Engineer\n- Centre of Excellence Head of Technology\n- Project Manager\n- Engineering Lead\n- Manager of Project Management Excellence\n- Technical Support Engineer\n- DevOps Engineer\n- Manager of BA Excellence\n- AI Engineer\n- Business Analyst\n\nEnsure that skills or areas of expertise are not treated as roles. The role should be singular, and it must correspond directly to the job title being classified or searched for.\n\nMAPPING RULES:\n- \"backend developer\" → Check for language mentioned: Python Engineer, Java Engineer, PHP Engineer, Ruby Engineer, Node.js Engineer, .NET Engineer\n- \"frontend developer\" → Check for framework mentioned: React Engineer, Angular Engineer, Vue.js Engineer  \n- \"full stack\" → Pick based on primary skill mentioned, or return null\n- \"mobile\" → Mobile Engineer\n- \"flutter developer\" -> Mobile Engineer\n- \"data scientist\" → Data Expert\n- \"ML\" or \"machine learning\" → AI Engineer\n- \"BA\" → Business Analyst\n- \"PM\" → Project Manager\n- \"PO\" → Product owner\n- \"SA\" → Solution Architect\n- \"QA\" or \"tester\" → QA Engineer\n- \"DevOps\" or \"SRE\" → DevOps Engineer\n- \"support\" → Technical Support Engineer\n- \"designer\" or \"UX\" or \"UI\" → UI/UX Designer\n- \"WordPress\" or \"CMS\" → WordPress Engineer\n\nSENIORITY LEVELS (use EXACTLY as written):\n- Novice\n- Junior 1\n- Junior 2\n- Mid 1\n- Mid 2\n- Senior 1\n- Senior 2\n\nMAPPING RULES FOR SENIORITY:\n- \"junior\" or \"entry level\" or \"beginner\" → Junior 1\n- \"mid\" or \"intermediate\" → Mid 1\n- \"senior\" or \"experienced\" or \"expert\" → Senior 1\n- If user says specific level like \"Senior 2\", use exactly that\n- If no seniority mentioned, return empty\n\nEMPLOYMENT TYPE (use EXACTLY as written):\n- Employee\n- Contractor\n- Student\n\nMAPPING RULES FOR EMPLOYMENT TYPE:\n- \"contractor\" or \"freelance\" or \"consultant\" or \"contract\" → Contractor\n- \"employee\" or \"full-time\" or \"permanent\" → Employee\n- If not mentioned, return empty\n\nINDUSTRIES (use EXACTLY as written):\n- Agriculture\n- Automotive\n- B2B\n- Banking & Insurance\n- Big Data\n- Civil Engineering\n- Content Distribution\n- Corporate (HR, Legal, Finance,..)\n- Crypto\n- Dental\n- E-commerce\n- Education\n- Entertainment & Sports\n- Fintech\n- FMCG\n- Food\n- Furniture\n- Government\n- Healthcare\n- Hospitality or Travel\n- Human Resources\n- IoT\n- Logistics\n- Maritime industry\n- Marketing\n- Media\n- Military or Law Enforcement\n- Pharma\n- Public Transportation\n- Publishing\n- Real Estate\n- Regulatory\n- Retail\n- SaaS\n- Social Media\n- Streaming\n- Telecommunications\n- White labeling\n\nMAPPING RULES FOR INDUSTRIES:\n- \"finance\" or \"financial\" → Fintech or Banking & Insurance\n- \"health\" or \"medical\" → Healthcare\n- \"pharma\" or \"pharmaceutical\" → Pharma\n- \"retail\" or \"shop\" → Retail\n- \"government\" or \"public sector\" → Government\n- \"telecom\" → Telecommunications\n- \"real estate\" or \"property\" → Real Estate\n- \"education\" or \"academic\" → Education\n- Return array of all mentioned industries\n- If no industry mentioned, return empty array\n\nSKILLS (use EXACTLY as written):\n- Web Slice/CSS/HTML\n- SEO\n- C# - .NET Framework\n- C# - .NET Core\n- C# - Unity\n- GO - beego\n- GO - gin\n- Java - J2EE\n- Java - Spring (Boot)\n- Kotlin - Ktor\n- Kotlin - Spring Boot\n- Kotlin - Micronaut\n- Node.js - Express\n- Node.js - Koa.js\n- Node.js - Meteor\n- Node.js - Nest.js\n- PHP - Laravel\n- PHP - Symfony\n- Python - DS/DE\n- Python - Django\n- Python - Flask\n- Ruby - Rails\n- Ruby - Sintara\n- Business analysis\n- CMS - CraftCMS\n- CMS - Drupal\n- CMS - Strapi\n- CMS - Wordpress\n- Data Scientist\n- Data Engineer\n- Design - UI\n- Design - UX\n- DevOps - AWS\n- DevOps - Azure\n- DevOps - CI/CD\n- DevOps - GCP\n- DevOps - Linux/Unix\n- DevOps - Networking/Security\n- DevOps - Windows\n- Digital Marketing\n- Magento - e-comm\n- Shopify - e-comm\n- Sylius - e-comm\n- WooCommerce - e-comm\n- JS - Angular\n- JS - Next.js\n- JS - React\n- JS - Vue.js\n- Android\n- Flutter\n- iOS\n- ReactNative\n- Presales Engineer\n- Product Owner\n- Product Strategy\n- Project Management\n- QA - Automated testing\n- QA - Functional testing\n- QA - Manual testing\n- QA - Nonfunctional testing\n- Solution Architect\n- Support Engineer\n- AI - Computer Vision\n- AI - Data Management and Preparation\n- AI - Generative AI\n- AI - LLM\n- AI - Machine Learning\n- AI - MLOps & LLMOps\n- AI - N8N\n- AI - Neural Networks\n- AI - Agents\n- AI - NLP\n- AI - Prompt Engineering\n- AI - RAG\n\nMAPPING RULES FOR SKILLS:\n- Only map EXPLICITLY mentioned skills\n- \"wordpress\" → CMS - Wordpress\n- \"machine learning\" or \"ML\" → AI - Machine Learning\n- \"LLM\" or \"large language model\" → AI - LLM\n- \"RAG\" or \"retrieval augmented generation\" → AI - RAG\n- \"prompting\" or \"prompt engineering\" → AI - Prompt Engineering\n- DO NOT add skills just because a technology family is mentioned (e.g., \"nodejs\" doesn't mean all Node.js frameworks)\n- Return array of ONLY explicitly mentioned skills\n- If no specific skills mentioned, return empty array\n\n\nReturn JSON with this schema:\n{\n    \"role\": \"string\",              // e.g., \"Node.js Engineer\"\n    \"seniority\": \"string or null\" // e.g., \"Senior 1\",\n    \"employment_type\": \"string\" //e.g., Employee/Contractor\n    \"industries\": [\"array of industries or empty array\"],\n    \"skills\": [\"array of skills or empty array\"]\n}\n`;\n\nreturn {\n  json: {\n    userPrompt,\n    systemPrompt: systemPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3296,
        272
      ],
      "id": "10bdf26b-f925-48aa-9ee1-0a894d207e0f",
      "name": "PreparePrompts - Knobs"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function — clean constraints JSON (string in .text) -> prompt-friendly texts\n// Outputs:\n//  - denseQueryText : \"Role, Seniority, Skills..., Industries..., Certs..., EmploymentType\"\n//  - skillText      : compact skills/role text (useful for 2-embedding AND or reranker)\n//  - domainText     : compact domain/industry/certs text (same reason)\n//  - sqlFilters     : simple filters you can pass to a filtered Supabase RPC\n//  - must, prefer   : pass-through parsed constraints\n//  - debug          : tokens used\n\nfunction arr(x) {\n  if (!x) return [];\n  if (Array.isArray(x)) return x;\n  return [x];\n}\nfunction normList(vs) {\n  return [...new Set(arr(vs)\n    .map(v => String(v || '').trim())\n    .filter(v => v.length > 0))];\n}\nfunction joinNonEmpty(parts, sep=', ') {\n  return parts.filter(Boolean).join(sep);\n}\n\n// 1) Read input\nconst incoming = await $input.all();\nif (!incoming.length) throw new Error('No input items.');\nlet raw = incoming[0].json?.text;\nif (typeof raw !== 'string' || !raw.trim()) {\n  raw = String(incoming[0].json ?? '');\n}\n\n// 2) Parse JSON\nlet parsed;\ntry { parsed = JSON.parse(raw); }\ncatch (e) { throw new Error('Invalid JSON in `text`: ' + e.message); }\n\nconst must   = parsed.must   || {};\n\n// 3) Normalize lists\nconst role           = normList(must.roles);\nconst skills      = normList(must.skills);\nconst seniority   = normList(must.seniority);          // may be empty\nconst industries = normList(must.industries);\nconst certificates       = normList(must.certs);\nconst employmentType        = normList(must.employment_type);\nconst notes   = normList(must.notes_contains);\n\n// 4) Optional tiny synonym nudges (edit to your taxonomy)\nfunction expandIndustries(list) {\n  const extra = [];\n  const set = new Set(list.map(s => s.toLowerCase()));\n  if (set.has('finance') || set.has('fintech') || set.has('banking')) {\n    extra.push('Fintech', 'Banking', 'Payments');\n  }\n  return normList([...list, ...extra]);\n}\nconst industriesExpanded = expandIndustries(industries);\n\nconst prefix = \"search_query\";\nconst userInput = $('ChatInput').first().json.chatInput;\nconst finalQuery = `${prefix}: ${userInput}`;\n\n// 5) Build tokens for the embedding query\nconst tokens = [\n  ...role,\n  ...seniority,\n  ...skills,\n  ...industriesExpanded,\n  ...certificates,\n  ...employmentType,\n  ...notes\n];\n\n// 6) Clean tokens (remove empties/nulls) and compose strings\nconst cleanTokens = normList(tokens);\nconst denseQueryText = joinNonEmpty(cleanTokens);\n\n// 8) Output\nreturn [{\n  json: {\n    finalQuery,\n    denseQueryText,   // e.g. \"Python Developer, Senior, Python, Finance, Fintech, Banking, GDPR, Contractor\"\n    role,\n    seniority,\n    skills,\n    industries,\n    certificates,\n    employmentType,\n    notes,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1648,
        -256
      ],
      "id": "77ac7598-0ac7-4b0a-9117-568fe08da20b",
      "name": "Knobs Formated"
    },
    {
      "parameters": {
        "jsCode": "// Generate reranker instruction with full dynamic handling for all query types\nfunction generateInstructionFromKnobs(queryKnobs) {\n    const knobs = queryKnobs;\n\n    // Check what information we actually have\n    const hasRole = knobs.role && knobs.role.length > 0;\n    const hasSkills = knobs.skills && knobs.skills.length > 0;\n    const hasIndustries = knobs.industries && knobs.industries.length > 0;\n    const hasCertificates = knobs.certificates && knobs.certificates.length > 0;\n    const hasEmploymentType = knobs.employmentType && knobs.employmentType.length > 0;\n    const hasSeniority = knobs.seniority && knobs.seniority.length > 0;\n    const hasNotes = knobs.notes && knobs.notes.length > 0;\n    \n    // Check if it's a detailed query (has role AND/OR skills)\n    const isDetailedQuery = hasRole || hasSkills;\n    \n    if (!isDetailedQuery) {\n        // Handle broad/specific-criteria queries\n        let instruction = \"Rank candidates using these specific criteria: \";\n        let criteriaCount = 1;\n        let hasCriteria = false;\n        \n        // Employment type\n        if (hasEmploymentType) {\n            instruction += `${criteriaCount}. EMPLOYMENT TYPE: Prioritize ${knobs.employmentType.join(\", \")} candidates. `;\n            criteriaCount++;\n            hasCriteria = true;\n        }\n        \n        // Certificates (HIGH PRIORITY for certificate-only searches)\n        if (hasCertificates) {\n            instruction += `${criteriaCount}. CERTIFICATES (HIGH PRIORITY): Must have ${knobs.certificates.join(\" or \")} certifications. `;\n            criteriaCount++;\n            hasCriteria = true;\n        }\n        \n        // Industry experience\n        if (hasIndustries) {\n            instruction += `${criteriaCount}. INDUSTRY EXPERIENCE: Must have ${knobs.industries.join(\", \")} industry experience. `;\n            criteriaCount++;\n            hasCriteria = true;\n        }\n        \n        // Seniority\n        if (hasSeniority) {\n            instruction += `${criteriaCount}. SENIORITY: Prefer ${knobs.seniority.join(\" or \")} level candidates. `;\n            criteriaCount++;\n            hasCriteria = true;\n        }\n        \n        // Notes (CRITICAL - handles language skills, soft skills, etc.)\n        if (hasNotes) {\n            instruction += `${criteriaCount}. SPECIFIC REQUIREMENTS (HIGH PRIORITY): Must match these criteria: ${knobs.notes.join(\", \")}. `;\n            criteriaCount++;\n            hasCriteria = true;\n        }\n        \n        // Default fallbacks only if we have some criteria\n        if (hasCriteria) {\n            instruction += `${criteriaCount}. ROLE PREFERENCE: Among matching candidates, prefer those with more relevant technical experience. `;\n            criteriaCount++;\n            instruction += `${criteriaCount}. EXPERIENCE LEVEL: Use overall experience as final tie-breaker. `;\n        } else {\n            // Truly empty query\n            instruction = \"Very broad query with no specific criteria. Rank by overall experience and technical competence. \";\n        }\n        \n        return instruction;\n    }\n    \n    // Detailed query logic (has role and/or skills)\n    let instruction = \"Rank candidates using this PRIORITY-BASED ORDER (higher priority ranks first): \";\n    \n    // 1. ROLE MATCHING (FULLY DYNAMIC)\n    instruction += \"1. ROLE PRIORITY (HIGHEST WEIGHT): \";\n    \n    if (hasRole) {\n        if (knobs.role.length === 1) {\n            instruction += `HIGHEST PRIORITY: Exact match for ${knobs.role[0]}. `;\n            instruction += `MEDIUM PRIORITY: Similar or related roles to ${knobs.role[0]}. `;\n            instruction += `LOWER PRIORITY: Roles with transferable skills or experience. `;\n        } else {\n            instruction += `HIGHEST PRIORITY: Exact match for any of these roles: ${knobs.role.join(\", \")}. `;\n            instruction += `MEDIUM PRIORITY: Roles closely related to the requested positions. `;\n            instruction += `LOWER PRIORITY: Roles with transferable skills. `;\n        }\n    }\n    \n    // 2. TECHNICAL SKILLS (FULLY DYNAMIC)\n    instruction += \"2. TECHNICAL SKILLS PRIORITY: \";\n    \n    if (hasSkills) {\n        // Dynamic domain skill detection instead of hardcoded filtering\n        const potentialDomainSkills = hasIndustries ? knobs.industries.map(ind => ind.toLowerCase()) : [];\n        const technicalSkills = knobs.skills.filter(skill => \n            !potentialDomainSkills.includes(skill.toLowerCase())\n        );\n        \n        if (technicalSkills.length > 0) {\n            if (technicalSkills.length === 1) {\n                instruction += `HIGHEST PRIORITY: Strong experience with ${technicalSkills[0]}. `;\n                instruction += `MEDIUM PRIORITY: Some experience with ${technicalSkills[0]} or related technologies. `;\n            } else {\n                instruction += `HIGHEST PRIORITY: Experience with multiple skills: ${technicalSkills.join(\", \")}. `;\n                instruction += `MEDIUM PRIORITY: Experience with some of these skills: ${technicalSkills.join(\", \")}. `;\n            }\n            instruction += `LOWER PRIORITY: Related or transferable technical skills. `;\n        }\n    }\n    \n    // 3. DOMAIN EXPERTISE (DYNAMIC)\n    if (hasIndustries) {\n        instruction += \"3. DOMAIN KNOWLEDGE BONUS: \";\n        instruction += `Add ranking boost for experience in: ${knobs.industries.join(\", \")}. `;\n    }\n    \n    // 4. SENIORITY (DYNAMIC)\n    if (hasSeniority) {\n        instruction += \"4. SENIORITY PREFERENCE: \";\n        instruction += `Prefer ${knobs.seniority.join(\" or \")} level candidates when other factors are similar. `;\n    }\n    \n    // 5. ADDITIONAL FACTORS (FULLY DYNAMIC)\n    let bonusFactors = [];\n    if (hasCertificates) {\n        bonusFactors.push(`${knobs.certificates.join(\", \")} certifications`);\n    }\n    if (hasEmploymentType) {\n        bonusFactors.push(`${knobs.employmentType.join(\", \")} experience`);\n    }\n    if (hasNotes) {\n        bonusFactors.push(`additional requirements: ${knobs.notes.join(\", \")}`);\n    }\n    \n    if (bonusFactors.length > 0) {\n        instruction += `5. BONUS FACTORS: Consider ${bonusFactors.join(\"; \")} as positive factors. `;\n    }\n    \n    instruction += \"RANKING STRATEGY: Prioritize exact matches first, then related/similar candidates, always considering the complete candidate profile.\";\n    \n    return instruction;\n}\n\n// NEW: Format query for Qwen3\nfunction formatQueryForQwen3(originalQuery, instruction) {\n    // Remove search_query prefix\n    const cleanQuery = originalQuery.replace(\"search_query:\", \"\").trim();\n    \n    // Qwen3 template format\n    const prefix = '<|im_start|>system\\nJudge whether the Document meets the requirements based on the Query and the Instruct provided. Note that the answer can only be \"yes\" or \"no\".<|im_end|>\\n<|im_start|>user\\n';\n    \n    const finalInstruction = instruction || \"Given a web search query, retrieve relevant passages that answer the query\";\n    \n    return `${prefix}<Instruct>: ${finalInstruction}\\n<Query>: ${cleanQuery}\\n`;\n}\n\n// Get the structured knobs from previous node\nconst queryKnobs = $input.first().json;\n\n// Generate precision instruction\nconst instruction = generateInstructionFromKnobs(queryKnobs);\n\n// Format query with instruction embedded\nconst formattedQuery = formatQueryForQwen3(queryKnobs.finalQuery, instruction);\n\n// Return the instruction along with original data\nreturn {\n    json: {\n        ...($input.first().json),\n        instruction: instruction,\n        finalQuery: queryKnobs.finalQuery,\n      formattedQuery\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1424,
        -256
      ],
      "id": "9fd5f194-a7f8-474c-b3ce-6f9a344269a6",
      "name": "Generate Reranking Instructions - Soft Prio"
    },
    {
      "parameters": {
        "jsCode": "// Extract all incoming items\nconst items = $input.all();\n\nfunction formatDocuments(documents) {\n    const suffix = '<|im_end|>\\n<|im_start|>assistant\\n<think>\\n\\n</think>\\n\\n';\n    return documents.map(doc => `<Document>: ${doc}${suffix}`);\n}\n\n// Collect only the 'embedding_facts_text' from each item\nconst documents = items.map(it => it.json.embedding_convo_text);\nconst formattedDocuments = formatDocuments(documents);\n\n// Build one output item\nreturn [\n  {\n    json: {\n      formattedDocuments\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1584,
        16
      ],
      "id": "cad6ab54-5be0-4bef-ae79-468c09c9235f",
      "name": "Format Documents"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.70:8020/v1/rerank",
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={{ $json.toJsonString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1024,
        16
      ],
      "id": "515a1013-41c3-4a5a-a047-1d68a42943ec",
      "name": "Rerank - Qwen3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "999fafa1-c0b1-4710-a1bd-5e9279dc38ab",
              "name": "chatInput",
              "value": "={{ $json.chatInput }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -3504,
        272
      ],
      "id": "ec2f5ef8-875f-4896-b777-956f83b0ddf5",
      "name": "ChatInput"
    },
    {
      "parameters": {
        "jsCode": "const chatInput = $('When chat message received').first().json.chatInput\nconst contextForPrompt = $input.first().json.llm_context\n\nconst systemPrompt = \"You are an AI assistant that helps pick employees for tasks and projects. Use ONLY the candidate snippets provided below.  Do NOT invent skills or industries. If a candidate clearly misses a must-have, you may omit them. Return a concise, useful answer.\";\n\n// 3. Define the user prompt\nconst userPrompt = `USER REQUEST:\n${chatInput}\n\nINSTRUCTIONS: $('Generate Reranking Instructions - Soft Prio').first().json.instruction\n\nCANDIDATE SNIPPETS (already sorted by semantic relevance; DO NOT change order):\n${contextForPrompt}\n\nINSTRUCTIONS:\n- Keep candidate order as-is.\n- For each included candidate, show:\n  • name (required)\n  id\n  employment_type\n  • role/section and seniority (if present in the snippet)\n  • 2–4 directly relevant skills/tech terms mentioned in the snippet\n  • 1–2 relevant industries/domains from the snippet that match the request\n  • A 2-line rationale grounded in the snippet (quote short phrases if helpful)\n- Prefer 3–5 candidates unless fewer obviously match.\n- If none match the must-haves, say so briefly.\n\nFORMAT:\nProvide a short paragraph summary, then a bullet list of candidates. If there no valid candidates, do not show them.\n`;\n\nreturn {\n  json: {\n    userPrompt,\n    systemPrompt: systemPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        -192
      ],
      "id": "7ee644f6-7ea9-4fc1-b8cb-62e6be928b1f",
      "name": "PreparePrompts1"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node\n// Input:  items[i].json.text  -> string containing JSON (possibly with newlines/code fences)\n// Output: items[i].json       -> parsed JSON object (or an _error field if parsing fails)\n\nreturn items.map((item) => {\n  let raw = (item.json?.text ?? '').trim();\n\n  // Strip Markdown code fences if present\n  if (raw.startsWith('```')) {\n    raw = raw.replace(/^```[a-zA-Z]*\\n?/, '').replace(/```$/, '').trim();\n  }\n\n  // If the string has extra wrapping text, try to extract the first JSON object\n  const maybeObj = raw.match(/{[\\s\\S]*}/);\n  if (maybeObj) raw = maybeObj[0];\n\n  try {\n    const parsed = JSON.parse(raw);\n    return { json: parsed };\n  } catch (e) {\n    // Fail gracefully but keep the original input for debugging\n    return { json: { _error: 'JSON parse failed', _message: e.message, _raw: item.json?.text } };\n  }\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2656,
        272
      ],
      "id": "66c35cb8-6274-4d7f-bc64-b673f4431c67",
      "name": "Create JSON"
    },
    {
      "parameters": {
        "jsCode": "// Configuration object for scoring weights\nconst SCORING_CONFIG = {\n  skills: {\n    senior: 30,\n    medium: 20,\n    junior: 10\n  },\n  role: 100,\n  seniority: 50,\n  employment: 25,\n  industry: 10 // per matching industry\n};\n\n// Helper function to escape SQL strings\nconst escapeSql = (str) => {\n  if (str === null || str === undefined) return '';\n  return String(str).replace(/'/g, \"''\");\n};\n\n// Helper to safely format array for PostgreSQL\nconst formatArray = (arr) => {\n  if (!arr || !Array.isArray(arr)) return null;\n  return `ARRAY[${arr.map(item => `'${escapeSql(item)}'`).join(',')}]::text[]`;\n};\n\nconst buildRoleQuery = (criteria, config = SCORING_CONFIG) => {\n  const requiredConditions = [];\n  const scoring = [];\n  const debugInfo = [];\n  \n  // Input validation and cleaning\n  const cleanCriteria = {\n    role: criteria?.role ? escapeSql(criteria.role) : null,\n    seniority: criteria?.seniority ? escapeSql(criteria.seniority) : null,\n    employment_type: criteria?.employment_type ? escapeSql(criteria.employment_type) : null,\n    industries: Array.isArray(criteria?.industries) && criteria.industries.length > 0 \n      ? criteria.industries.map(escapeSql) : null,\n    skills: Array.isArray(criteria?.skills) && criteria.skills.length > 0 \n      ? criteria.skills.map(escapeSql) : null,\n    // Optional: Add flexibility for skill matching\n    skillMatchMode: criteria?.skillMatchMode || 'ALL', // 'ALL' or 'ANY'\n    // Optional: Limit results\n    limit: criteria?.limit || 20\n  };\n  \n  debugInfo.push(`Skill match mode: ${cleanCriteria.skillMatchMode}`);\n  \n  // Base query with all fields\n  let sql = `\n    SELECT \n      id,\n      name,\n      role,\n      seniority,\n      employment_type,\n      industries,\n      skills_senior,\n      skills_medium,\n      skills_junior`;\n  \n  // Skills handling with configurable matching\n  if (cleanCriteria.skills) {\n    const skillConditions = [];\n    const skillScoring = [];\n    \n    cleanCriteria.skills.forEach((skill, index) => {\n      const skillCondition = `('${skill}' = ANY(skills_senior) OR '${skill}' = ANY(skills_medium) OR '${skill}' = ANY(skills_junior))`;\n      skillConditions.push(skillCondition);\n      \n      // Individual skill scoring\n      skillScoring.push(`\n        CASE \n          WHEN '${skill}' = ANY(skills_senior) THEN ${config.skills.senior}\n          WHEN '${skill}' = ANY(skills_medium) THEN ${config.skills.medium}\n          WHEN '${skill}' = ANY(skills_junior) THEN ${config.skills.junior}\n          ELSE 0 \n        END`);\n    });\n    \n    // Apply skill matching mode\n    if (cleanCriteria.skillMatchMode === 'ALL') {\n      requiredConditions.push(`(${skillConditions.join(' AND ')})`);\n      debugInfo.push(`Required: ALL of ${cleanCriteria.skills.length} skills`);\n    } else {\n      requiredConditions.push(`(${skillConditions.join(' OR ')})`);\n      debugInfo.push(`Required: ANY of ${cleanCriteria.skills.length} skills`);\n    }\n    \n    scoring.push(...skillScoring);\n  }\n  \n  // Role scoring (optional - not a filter)\n  if (cleanCriteria.role) {\n    scoring.push(`CASE WHEN role = '${cleanCriteria.role}' THEN ${config.role} ELSE 0 END`);\n    debugInfo.push(`Preferred role: ${cleanCriteria.role} (+${config.role} points)`);\n  }\n  \n  // Seniority (required filter + scoring)\n  if (cleanCriteria.seniority) {\n    requiredConditions.push(`seniority = '${cleanCriteria.seniority}'`);\n    scoring.push(`CASE WHEN seniority = '${cleanCriteria.seniority}' THEN ${config.seniority} ELSE 0 END`);\n    debugInfo.push(`Required seniority: ${cleanCriteria.seniority}`);\n  }\n  \n  // Employment type (required filter + scoring)\n  if (cleanCriteria.employment_type) {\n    requiredConditions.push(`employment_type = '${cleanCriteria.employment_type}'`);\n    scoring.push(`CASE WHEN employment_type = '${cleanCriteria.employment_type}' THEN ${config.employment} ELSE 0 END`);\n    debugInfo.push(`Required employment: ${cleanCriteria.employment_type}`);\n  }\n  \n  // Industries (at least one match required + scoring)\n  if (cleanCriteria.industries) {\n    const industriesArray = formatArray(cleanCriteria.industries);\n    requiredConditions.push(`industries && ${industriesArray}`);\n    \n    // Score based on number of matching industries\n    scoring.push(`\n      (SELECT COUNT(*) * ${config.industry} \n       FROM unnest(industries) AS ind \n       WHERE ind = ANY(${industriesArray}))`);\n    debugInfo.push(`Required industries: ${cleanCriteria.industries.join(', ')}`);\n  }\n  \n  // Add scoring column if we have any scoring criteria\n  if (scoring.length > 0) {\n    sql += `,\n      (${scoring.join(' +\\n        ')}) AS total_score`;\n    \n    // Add individual score breakdowns for debugging\n    if (criteria?.debug) {\n      cleanCriteria.skills?.forEach((skill, index) => {\n        sql += `,\n      CASE \n        WHEN '${skill}' = ANY(skills_senior) THEN ${config.skills.senior}\n        WHEN '${skill}' = ANY(skills_medium) THEN ${config.skills.medium}\n        WHEN '${skill}' = ANY(skills_junior) THEN ${config.skills.junior}\n        ELSE 0 \n      END AS score_skill_${index + 1}`;\n      });\n    }\n  }\n  \n  sql += `\n    FROM ganttic_api_resources`;\n  \n  // Add WHERE clause if we have required conditions\n  if (requiredConditions.length > 0) {\n    sql += `\n    WHERE ${requiredConditions.join(' AND ')}`;\n  }\n  \n  // Add ORDER BY and LIMIT\n  sql += `\n    ORDER BY ${scoring.length > 0 ? 'total_score DESC' : 'name ASC'}\n    LIMIT ${cleanCriteria.limit}`;\n  \n  // Return both query and debug info for n8n logging\n  return {\n    query: sql,\n    debug: debugInfo,\n    criteriaUsed: cleanCriteria,\n    scoringConfig: config\n  };\n};\n\n// n8n execution\nconst input = $input.first().json;\n\n// Example of adding configuration override from input\nconst customConfig = input.scoringConfig || SCORING_CONFIG;\n\n// Build the query with optional debug mode\nconst result = buildRoleQuery({\n  ...input,\n  debug: input.debug || false // Set to true to get score breakdowns\n}, customConfig);\n\n// Log for n8n console\nconsole.log('Query built successfully');\nconsole.log('Debug info:', result.debug);\n\nreturn {\n  json: result\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2448,
        272
      ],
      "id": "f0d00741-c7cb-46cc-8628-ce178d80cdb6",
      "name": "Query"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{ $json.query }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -2240,
        272
      ],
      "id": "da06b492-79c3-4efd-804d-8013d72b1ee8",
      "name": "Execute a SQL query",
      "credentials": {
        "postgres": {
          "id": "wK2pSCG9jTniRU28",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const buildRoleQuery = (criteria) => {\n  const conditions = [];\n  const scoring = [];\n  \n  // Clean the input - handle nulls and empty strings\n  const cleanCriteria = {\n    role: criteria.role || null,\n    seniority: criteria.seniority || null,\n    employment_type: criteria.employment_type || null,\n    industries: criteria.industries?.length > 0 ? criteria.industries : null,\n    skills: criteria.skills?.length > 0 ? criteria.skills : null\n  };\n  \n  let sql = `\n    SELECT \n      id,\n      name,\n      role,\n      seniority,\n      employment_type,\n      skills_senior,\n      skills_medium,\n      skills_junior`;\n  \n  // Add role scoring and condition if specified\n  if (cleanCriteria.role) {\n    conditions.push(`role = '${cleanCriteria.role}'`);\n    scoring.push(`CASE WHEN role = '${cleanCriteria.role}' THEN 100 ELSE 0 END`);\n  }\n  \n  // Add seniority scoring and condition if specified\n  if (cleanCriteria.seniority) {\n    conditions.push(`seniority = '${cleanCriteria.seniority}'`);\n    scoring.push(`CASE WHEN seniority = '${cleanCriteria.seniority}' THEN 50 ELSE 0 END`);\n  }\n  \n  // Add employment_type if specified\n  if (cleanCriteria.employment_type) {\n    conditions.push(`employment_type = '${cleanCriteria.employment_type}'`);\n    scoring.push(`CASE WHEN employment_type = '${cleanCriteria.employment_type}' THEN 25 ELSE 0 END`);\n  }\n  \n  // Add scoring column if we have any scores\n  if (scoring.length > 0) {\n    sql += `,\n      (${scoring.join(' + ')}) AS total_score`;\n  }\n  \n  sql += `\n    FROM ganttic_api_resources`;\n  \n  // Add WHERE clause if we have conditions\n  if (conditions.length > 0) {\n    sql += `\n    WHERE ${conditions.join(' AND ')}`;\n  }\n  \n  // Order by score if we have scoring, otherwise by name\n  sql += `\n    ORDER BY ${scoring.length > 0 ? 'total_score DESC' : 'name'}\n    LIMIT 20`;\n  \n  return sql;\n};\n\n// Test with your input\nconst input = $input.first().json;\n\nconst query = buildRoleQuery(input);\nconsole.log(query);\n\nreturn {\n  json: {\n    query\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2384,
        -176
      ],
      "id": "482dae3c-099f-4e11-b81c-9aa514cd5be0",
      "name": "Query1"
    },
    {
      "parameters": {
        "jsCode": "const buildRoleQuery = (criteria) => {\n  const conditions = [];\n  const scoring = [];\n  \n  // Clean the input - handle nulls and empty strings\n  const cleanCriteria = {\n    role: criteria.role || null,\n    seniority: criteria.seniority || null,\n    employment_type: criteria.employment_type || null,\n    industries: criteria.industries?.length > 0 ? criteria.industries : null,\n    skills: criteria.skills?.length > 0 ? criteria.skills : null\n  };\n  \n  let sql = `\n    SELECT \n      id,\n      name,\n      role,\n      seniority,\n      employment_type,\n      industries,\n      skills_senior,\n      skills_medium,\n      skills_junior`;\n  \n  // Add role scoring and condition if specified\n  if (cleanCriteria.role) {\n    conditions.push(`role = '${cleanCriteria.role}'`);\n    scoring.push(`CASE WHEN role = '${cleanCriteria.role}' THEN 100 ELSE 0 END`);\n  }\n  \n  // Add seniority scoring and condition if specified\n  if (cleanCriteria.seniority) {\n    conditions.push(`seniority = '${cleanCriteria.seniority}'`);\n    scoring.push(`CASE WHEN seniority = '${cleanCriteria.seniority}' THEN 50 ELSE 0 END`);\n  }\n  \n  // Add employment_type if specified\n  if (cleanCriteria.employment_type) {\n    conditions.push(`employment_type = '${cleanCriteria.employment_type}'`);\n    scoring.push(`CASE WHEN employment_type = '${cleanCriteria.employment_type}' THEN 25 ELSE 0 END`);\n  }\n  \n  // Add industries if specified\n  if (cleanCriteria.industries) {\n    conditions.push(`industries && ARRAY[${cleanCriteria.industries.map(i => `'${i}'`).join(',')}]::text[]`);\n    scoring.push(`\n      (SELECT COUNT(*) * 10 \n       FROM unnest(industries) AS ind \n       WHERE ind = ANY(ARRAY[${cleanCriteria.industries.map(i => `'${i}'`).join(',')}]::text[]))\n    `);\n  }\n  \n  // Add skills if specified - CHECK ALL THREE SKILL LEVELS\n  if (cleanCriteria.skills) {\n    const skillConditions = [];\n    cleanCriteria.skills.forEach((skill, index) => {\n      // Each skill must exist in at least one level\n      skillConditions.push(\n        `('${skill}' = ANY(skills_senior) OR '${skill}' = ANY(skills_medium) OR '${skill}' = ANY(skills_junior))`\n      );\n      \n      // Score based on skill level\n      scoring.push(`\n        CASE \n          WHEN '${skill}' = ANY(skills_senior) THEN 30\n          WHEN '${skill}' = ANY(skills_medium) THEN 20\n          WHEN '${skill}' = ANY(skills_junior) THEN 10\n          ELSE 0 \n        END\n      `);\n    });\n    \n    // Must have ALL requested skills (change to OR if you want ANY)\n    conditions.push(`(${skillConditions.join(' AND ')})`);\n  }\n  \n  // Add scoring column if we have any scores\n  if (scoring.length > 0) {\n    sql += `,\n      (${scoring.join(' + ')}) AS total_score`;\n  }\n  \n  sql += `\n    FROM ganttic_api_resources`;\n  \n  // Add WHERE clause if we have conditions\n  if (conditions.length > 0) {\n    sql += `\n    WHERE ${conditions.join(' AND ')}`;\n  }\n  \n  // Order by score if we have scoring, otherwise by name\n  sql += `\n    ORDER BY ${scoring.length > 0 ? 'total_score DESC' : 'name'}\n    LIMIT 20`;\n  \n  return sql;\n};\n\nconst input = $input.first().json;\n\nconst query = buildRoleQuery(input);\nconsole.log(query);\nreturn {\n  json: {\n    query\n  }\n};\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2144,
        -160
      ],
      "id": "0dea18c9-5610-437f-9907-6251e77cec1b",
      "name": "Query2"
    },
    {
      "parameters": {
        "jsCode": "const buildRoleQuery = (criteria) => {\n  const requiredConditions = [];\n  const optionalConditions = [];\n  const scoring = [];\n  \n  // Clean the input\n  const cleanCriteria = {\n    role: criteria.role || null,\n    seniority: criteria.seniority || null,\n    employment_type: criteria.employment_type || null,\n    industries: criteria.industries?.length > 0 ? criteria.industries : null,\n    skills: criteria.skills?.length > 0 ? criteria.skills : null\n  };\n  \n  let sql = `\n    SELECT \n      id,\n      name,\n      role,\n      seniority,\n      employment_type,\n      industries,\n      skills_senior,\n      skills_medium,\n      skills_junior`;\n  \n  // REQUIRED: Skills (if specified) - must have ALL skills\n  if (cleanCriteria.skills) {\n    const skillConditions = [];\n    cleanCriteria.skills.forEach((skill) => {\n      skillConditions.push(\n        `('${skill}' = ANY(skills_senior) OR '${skill}' = ANY(skills_medium) OR '${skill}' = ANY(skills_junior))`\n      );\n      \n      scoring.push(`\n        CASE \n          WHEN '${skill}' = ANY(skills_senior) THEN 30\n          WHEN '${skill}' = ANY(skills_medium) THEN 20\n          WHEN '${skill}' = ANY(skills_junior) THEN 10\n          ELSE 0 \n        END\n      `);\n    });\n    requiredConditions.push(`(${skillConditions.join(' AND ')})`);\n  }\n  \n  // OPTIONAL: Role - just adds score\n  if (cleanCriteria.role) {\n    scoring.push(`CASE WHEN role = '${cleanCriteria.role}' THEN 100 ELSE 0 END`);\n  }\n  \n  // REQUIRED: Seniority\n  if (cleanCriteria.seniority) {\n    requiredConditions.push(`seniority = '${cleanCriteria.seniority}'`);\n    scoring.push(`CASE WHEN seniority = '${cleanCriteria.seniority}' THEN 50 ELSE 0 END`);\n  }\n  \n  // REQUIRED: Employment type\n  if (cleanCriteria.employment_type) {\n    requiredConditions.push(`employment_type = '${cleanCriteria.employment_type}'`);\n    scoring.push(`CASE WHEN employment_type = '${cleanCriteria.employment_type}' THEN 25 ELSE 0 END`);\n  }\n  \n  // REQUIRED: Industries (at least one match)\n  if (cleanCriteria.industries) {\n    requiredConditions.push(`industries && ARRAY[${cleanCriteria.industries.map(i => `'${i}'`).join(',')}]::text[]`);\n    scoring.push(`\n      (SELECT COUNT(*) * 10 \n       FROM unnest(industries) AS ind \n       WHERE ind = ANY(ARRAY[${cleanCriteria.industries.map(i => `'${i}'`).join(',')}]::text[]))\n    `);\n  }\n  \n  // Add scoring column\n  if (scoring.length > 0) {\n    sql += `,\n      (${scoring.join(' + ')}) AS total_score`;\n  }\n  \n  sql += `\n    FROM ganttic_api_resources`;\n  \n  // Add WHERE clause with only required conditions\n  if (requiredConditions.length > 0) {\n    sql += `\n    WHERE ${requiredConditions.join(' AND ')}`;\n  }\n  \n  sql += `\n    ORDER BY ${scoring.length > 0 ? 'total_score DESC' : 'name'}\n    LIMIT 20`;\n  \n  return sql;\n};\n\nconst input = $input.first().json;\n\nconst query = buildRoleQuery(input);\nconsole.log(query);\nreturn {\n  json: {\n    query\n  }\n};\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        -112
      ],
      "id": "b4757623-7978-4b4d-996d-e114b21a84d7",
      "name": "Query3"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node for formatting search results with LLM\n\nconst searchResults = $input.all() // Your 20 results\nconst originalQuery = $('ChatInput').first().json.chatInput // User's original question\nconst searchCriteria =  $('Query').first().json.criteriaUsed // What was searched for\n\n// System prompt for consistent, helpful formatting\nconst systemPrompt = `You are a helpful staffing assistant. Format employee search results in a conversational, actionable way.\nYour responses should be:\n- Concise but informative\n- Highlight the best matches and explain why\n- Group similar candidates when appropriate\n- Flag important differences (contractor vs employee)\n- Be honest about partial matches\n- Suggest next steps\n\nIMPORTANT RULES:\n- If 0 results: Explain what was searched and suggest alternatives\n- If 1-3 results: Detail each person\n- If 4-10 results: Detail top 3, summarize others\n- If 11-20 results: Detail top 3, group others by role/skills\n- Always mention total count\n- Highlight standout qualifications\n- Note any concerns (e.g., \"only has medium-level React skills\")\n- Use names in bold: **Name**\n- Keep response under 300 words unless specifically analyzing`;\n\n// User prompt with context and results\nconst userPrompt = `Original request: \"${originalQuery}\"\n\nSearch criteria used:\n- Role: ${searchCriteria.role || 'Any'}\n- Seniority: ${searchCriteria.seniority || 'Any'}\n- Employment: ${searchCriteria.employment_type || 'Any'}\n- Industries: ${searchCriteria.industries?.join(', ') || 'Any'}\n- Skills: ${searchCriteria.skills?.join(', ') || 'Any'}\n\nResults found (${searchResults.length} matches):\n${JSON.stringify(searchResults, null, 2)}\n\nPlease provide a helpful response to the user's original request. Focus on:\n1. Who are the top candidates and why\n2. Any perfect matches vs partial matches\n3. Important distinctions (contractor/employee, skill levels)\n4. Actionable recommendations`;\n\n// Alternative templates for specific scenarios\nconst templates = {\n  noResults: `I couldn't find any exact matches for your criteria. You searched for:\n- Role: {role}\n- Seniority: {seniority}\n- Skills: {skills}\n\nSuggestions:\n1. Broaden the seniority level\n2. Consider contractors instead of employees\n3. Look for related skills (e.g., Vue.js instead of React)\n\nWould you like me to search again with adjusted criteria?`,\n\n  perfectMatch: `Great news! I found a perfect match:\n\n**{name}** - {role}\n- ✅ {seniority} level\n- ✅ {employment_type}\n- ✅ Senior-level expertise in {skills}\n- ✅ Experience in {industries}\n- Overall match score: {score}\n\nThey meet all your requirements. Would you like to check their availability?`,\n\n  multipleGoodMatches: `I found {count} excellent candidates for your {role} position:\n\n**Top Recommendations:**\n{top_candidates}\n\n**Other Strong Candidates:**\n{other_candidates}\n\nAll candidates have the required {skills} experience. The top picks have the best combination of seniority and industry experience.`\n};\n\n// Function to pre-process results for better LLM formatting\nconst preprocessResults = (results) => {\n  return results.map(person => {\n    // Identify skill levels for requested skills\n    const skillLevels = {};\n    if (searchCriteria.skills) {\n      searchCriteria.skills.forEach(skill => {\n        if (person.skills_senior?.includes(skill)) {\n          skillLevels[skill] = 'Senior';\n        } else if (person.skills_medium?.includes(skill)) {\n          skillLevels[skill] = 'Medium';\n        } else if (person.skills_junior?.includes(skill)) {\n          skillLevels[skill] = 'Junior';\n        }\n      });\n    }\n    \n    return {\n      name: person.name,\n      role: person.role,\n      seniority: person.seniority,\n      employment_type: person.employment_type,\n      score: person.total_score,\n      industries: person.industries?.slice(0, 3), // Top 3 industries only\n      requested_skill_levels: skillLevels,\n      is_perfect_match: person.total_score > 150 && person.role === searchCriteria.role\n    };\n  });\n};\n\n// Enhanced version with analysis\nconst createAnalyticalResponse = (results, criteria) => {\n  const analysis = {\n    perfectMatches: results.filter(r => r.total_score > 150),\n    goodMatches: results.filter(r => r.total_score >= 100 && r.total_score <= 150),\n    partialMatches: results.filter(r => r.total_score < 100),\n    contractors: results.filter(r => r.employment_type === 'Contractor'),\n    employees: results.filter(r => r.employment_type === 'Employee'),\n    byRole: {}\n  };\n  \n  // Group by role\n  results.forEach(r => {\n    if (!analysis.byRole[r.role]) {\n      analysis.byRole[r.role] = [];\n    }\n    analysis.byRole[r.role].push(r);\n  });\n  \n  return analysis;\n};\n\n// Format for Slack/chat (more concise)\nconst chatFormat = (results, criteria) => {\n  if (results.length === 0) {\n    return `No matches found for ${criteria.role || 'the position'}. Try broadening your search.`;\n  }\n  \n  if (results.length === 1) {\n    const person = results[0];\n    return `Found 1 match: **${person.name}** (${person.role}, ${person.seniority}, ${person.employment_type}). Score: ${person.total_score}/200`;\n  }\n  \n  const top3 = results.slice(0, 3);\n  let response = `Found ${results.length} candidates:\\n\\n**Top matches:**\\n`;\n  \n  top3.forEach((person, idx) => {\n    response += `${idx + 1}. **${person.name}** - ${person.role} (${person.employment_type}, Score: ${person.total_score})\\n`;\n  });\n  \n  if (results.length > 3) {\n    response += `\\n...and ${results.length - 3} more. Want details?`;\n  }\n  \n  return response;\n};\n\n// Decision logic for which format to use\nconst shouldUseTemplate = (results) => {\n  if (results.length === 0) return 'noResults';\n  if (results.length === 1 && results[0].total_score > 150) return 'perfectMatch';\n  if (results.length > 1 && results.filter(r => r.total_score > 100).length >= 3) return 'multipleGoodMatches';\n  return null;\n};\n\n// Main execution\nconst processedResults = preprocessResults(searchResults);\nconst analysis = createAnalyticalResponse(searchResults, searchCriteria);\nconst templateChoice = shouldUseTemplate(searchResults);\n\n// Add insights to the prompt\nconst insightsPrompt = `\nAdditional insights:\n- Perfect matches (score >150): ${analysis.perfectMatches.length}\n- Good matches (score 100-150): ${analysis.goodMatches.length}\n- Contractors available: ${analysis.contractors.length}\n- Employees available: ${analysis.employees.length}\n- Different roles found: ${Object.keys(analysis.byRole).length}\n`;\n\n// Return enhanced prompt\nreturn {\n  json: {\n    systemPrompt,\n    userPrompt: userPrompt + insightsPrompt,\n    processedResults,\n    analysis,\n    quickResponse: chatFormat(searchResults, searchCriteria),\n    template: templateChoice\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1968,
        352
      ],
      "id": "6c43d71b-3780-4735-bd11-b54239f6545c",
      "name": "Code"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "qwen3-coder-30b-32k",
          "mode": "list",
          "cachedResultName": "qwen3-coder-30b-32k"
        },
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1504,
        576
      ],
      "id": "39bb2d53-5c9b-49c4-b686-ce3c37698ea1",
      "name": "VLLM2",
      "credentials": {
        "openAiApi": {
          "id": "09tIxrZPXx1gwPgx",
          "name": "vllm"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.userPrompt }}",
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.systemPrompt }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -1504,
        368
      ],
      "id": "f6e6cdb0-d4a8-4dbb-a1eb-005da97ac3d1",
      "name": "Generate Response1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "claude-sonnet-4-20250514",
          "cachedResultName": "Claude 4 Sonnet"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        -3040,
        576
      ],
      "id": "2fe54763-1862-4c4b-b0a8-c8133c07aa30",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "qzCm5Ds2qD9ZY1W5",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -2944,
        672
      ],
      "id": "8fc839e8-9955-43c6-8e61-d10701a32fa4",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "M8xqWvEC6mH6LNuk",
          "name": "OpenAi account"
        }
      }
    }
  ],
  "pinData": {},
  "repo_name": "n8n-backup-zm",
  "repo_owner": "zlatkomq",
  "repo_path": "",
  "settings": {
    "executionOrder": "v1"
  },
  "shared": [
    {
      "createdAt": "2025-09-15T12:34:50.446Z",
      "updatedAt": "2025-09-15T12:34:50.446Z",
      "role": "workflow:owner",
      "workflowId": "ebQji26wK8qqgo37",
      "projectId": "NM7VZoSXkcKo262s"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-09-23T21:45:52.317Z",
  "versionId": "1e6bf03d-6944-445e-8893-67c981afc84f"
}