{
  "active": true,
  "connections": {
    "On form submission": {
      "main": [
        [
          {
            "node": "MD5 Hash",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Upload RFP to Supabase": {
      "main": [
        [
          {
            "node": "fileLink",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "MD5 Hash": {
      "main": [
        [
          {
            "node": "Filename & Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filename & Hash": {
      "main": [
        [
          {
            "node": "Crate RFP Table Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Crate RFP Table Name": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Upload RFP to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RFP Upload Web New": {
      "main": [
        [
          {
            "node": "MD5 Hash",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Create RFP Table": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RFP List Table Add": {
      "main": [
        [
          {
            "node": "Create RFP Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Responds To Rest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fileLink": {
      "main": [
        [
          {
            "node": "RFP List Table Add",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Session ID and prepare file data": {
      "main": [
        [
          {
            "node": "Add Execution id",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download File": {
      "main": [
        [
          {
            "node": "Chunker Full1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker Full": {
      "main": [
        []
      ]
    },
    "Optimize Chunks": {
      "main": [
        [
          {
            "node": "Merge with original chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PreparePrompts - Metadata Enrichment": {
      "main": [
        [
          {
            "node": "Optimize Chunks - Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert or update rows in a table": {
      "main": [
        [
          {
            "node": "Delete row(s)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove TOC1": {
      "main": [
        [
          {
            "node": "Final Escaping1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Escaping1": {
      "main": [
        [
          {
            "node": "Only Big Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Output1": {
      "main": [
        [
          {
            "node": "Remove Search Documents prefix",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Topics": {
      "ai_outputParser": [
        [
          {
            "node": "Optimize Chunks - Metadata",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Subchunking": {
      "ai_outputParser": [
        [
          {
            "node": "Optimize Chunks",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Only Big Chunks": {
      "main": [
        [
          {
            "node": "PreparePrompts - subchunking",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PreparePrompts - subchunking": {
      "main": [
        [
          {
            "node": "Optimize Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Qwen": {
      "ai_languageModel": [
        []
      ]
    },
    "Google Gemini - Payed": {
      "ai_languageModel": [
        [
          {
            "node": "Optimize Chunks - Metadata",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Topics",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Optimize Chunks - Metadata": {
      "main": [
        [
          {
            "node": "Add Metadata to Original",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Metadata to Original": {
      "main": [
        [
          {
            "node": "Prepare Embedding Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embed Chunks1": {
      "main": [
        [
          {
            "node": "Embedding Isolated1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embedding Isolated1": {
      "main": [
        [
          {
            "node": "Insert or update rows in a table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Execution id": {
      "main": [
        [
          {
            "node": "Download File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini - Payed1": {
      "ai_languageModel": [
        [
          {
            "node": "Subchunking",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Optimize Chunks",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Merge with original chunks": {
      "main": [
        [
          {
            "node": "Add topic to Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add topic to Text": {
      "main": [
        [
          {
            "node": "PreparePrompts - Metadata Enrichment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Search Documents prefix": {
      "main": [
        [
          {
            "node": "Remove TOC1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Embedding Text": {
      "main": [
        [
          {
            "node": "Embed Chunks1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Get Session ID and prepare file data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields1": {
      "main": [
        []
      ]
    },
    "Delete row(s)": {
      "main": [
        [
          {
            "node": "Edit Fields1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker Full1": {
      "main": [
        [
          {
            "node": "Format Output1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-10-20T12:49:28.945Z",
  "id": "aKpGZQLxTLr3FkPY",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "RFP Analysis Public - Ingestion",
  "nodes": [
    {
      "parameters": {
        "formTitle": "rfp",
        "formFields": {
          "values": [
            {
              "fieldLabel": "data",
              "fieldType": "file",
              "acceptFileTypes": ".pdf"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.3,
      "position": [
        -1808,
        -192
      ],
      "id": "d19e6016-b20b-4052-b121-e15aabbba4ac",
      "name": "On form submission",
      "webhookId": "f446b01e-feae-4b8c-b2b7-83754f5d27c7"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT create_rfp_table('{{ $('Merge').item.json.tableName}}');",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1184,
        432
      ],
      "id": "a57fd99d-6c51-4ede-b9ec-c95011ff70f7",
      "name": "Create RFP Table",
      "credentials": {
        "postgres": {
          "id": "wK2pSCG9jTniRU28",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://wrdntxsgwastvpyxdnmq.supabase.co/storage/v1/object/rfps/{{ $json.tableNameWithExtension }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-upsert",
              "value": "true"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "file",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -1184,
        192
      ],
      "id": "f338ba85-c2b6-4b15-93de-c61dade0064c",
      "name": "Upload RFP to Supabase",
      "credentials": {
        "httpHeaderAuth": {
          "id": "D263AfEvYnYc9WQX",
          "name": "Suabase Header Auth"
        }
      }
    },
    {
      "parameters": {
        "binaryData": true,
        "binaryPropertyName": "file",
        "dataPropertyName": "hash"
      },
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        -1392,
        -32
      ],
      "id": "1c39faf7-e463-40c5-a25f-43f782178503",
      "name": "MD5 Hash",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1e013de4-48b6-4e4c-97eb-4caf21b5d2a1",
              "name": "rfp_filename",
              "value": "={{ $('RFP Upload Web New').item.binary.file.fileName }}",
              "type": "string"
            },
            {
              "id": "16dff88e-0386-4909-9221-42cb67296b97",
              "name": "rfp_filetype",
              "value": "={{ $('RFP Upload Web New').item.binary.file.fileType }}",
              "type": "string"
            },
            {
              "id": "d423ca20-1979-441c-a7cf-06b18849d6d4",
              "name": "rfp_mimetype",
              "value": "={{ $('RFP Upload Web New').item.binary.file.mimeType }}",
              "type": "string"
            },
            {
              "id": "e4ff9202-6df2-4f20-baf8-8ba15d722701",
              "name": "rfp_filesize",
              "value": "={{ $('RFP Upload Web New').item.binary.file.fileSize }}",
              "type": "string"
            },
            {
              "id": "330a750a-6468-460a-9904-06598a2af73f",
              "name": "rfp_extension",
              "value": "={{ $('RFP Upload Web New').item.binary.file.fileExtension }}",
              "type": "string"
            },
            {
              "id": "20e357d8-b889-4c6d-9679-7ea736c665b4",
              "name": "hash",
              "value": "={{ $json.hash }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1184,
        -32
      ],
      "id": "db321b4f-fb34-4789-8cd2-d29b1b6aa636",
      "name": "Filename & Hash"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\n\n// Ensure required input\nif (!item.rfp_filename) throw new Error(\"rfp_filename is required\");\nif (!item.hash) throw new Error(\"hash is required\");\n\n// --- Use provided extension or extract it ---\nconst extension = item.rfp_extension || item.rfp_filetype || (() => {\n  const lastDotIndex = item.rfp_filename.lastIndexOf('.');\n  const hasExtension = lastDotIndex > 0 && lastDotIndex < item.rfp_filename.length - 1;\n  return hasExtension ? item.rfp_filename.slice(lastDotIndex + 1) : '';\n})();\n\n// --- Extract filename without extension ---\nconst lastDotIndex = item.rfp_filename.lastIndexOf('.');\nconst hasExtension = lastDotIndex > 0 && lastDotIndex < item.rfp_filename.length - 1;\nconst filenameWithoutExt = hasExtension ? item.rfp_filename.slice(0, lastDotIndex) : item.rfp_filename;\n\n// --- Create slug from filename (without extension) ---\nconst slug = filenameWithoutExt\n  .toLowerCase()\n  .replace(/[^a-z0-9]+/g, '_')   // replace invalid chars with underscores\n  .replace(/^_+|_+$/g, '');      // trim leading/trailing underscores\n\n// --- Shorten hash to safe length ---\nconst shortHash = item.hash.slice(0, 4);\n\n// --- Combine into a table name ---\nconst tableName = `rfp_${slug}_${shortHash}`;\n\n// --- Enforce max length (63 chars for PostgreSQL) ---\nconst finalTableName = tableName.slice(0, 63);\n\n// --- Add table name with extension for file naming ---\nconst tableNameWithExtension = extension ? `${finalTableName}.${extension}` : finalTableName;\n\nreturn [{\n  json: {\n    ...item,\n    slug,\n    tableName: finalTableName,\n    tableNameWithExtension,\n    extension\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -992,
        -32
      ],
      "id": "5521f0aa-c0ae-44d1-99c2-ea9b076af49c",
      "name": "Crate RFP Table Name"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1392,
        192
      ],
      "id": "f5cd8d03-0f0e-4f76-9658-eb7bd1cff442",
      "name": "Merge"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rfp-upload",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1808,
        -16
      ],
      "id": "dd024141-af32-484f-9891-20fa51bb80fb",
      "name": "RFP Upload Web New",
      "webhookId": "663a2e7d-35dd-4241-8890-97393732bb42"
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "rfp_list",
          "mode": "name"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "file_name": "={{ $('Crate RFP Table Name').item.json.rfp_filename }}",
            "table_name": "={{ $('Crate RFP Table Name').item.json.tableName }}",
            "md5": "={{ $('Crate RFP Table Name').item.json.hash }}",
            "link": "={{ $json.publicUrl }}",
            "id": "={{ $('Upload RFP to Supabase').item.json.Id }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "md5",
              "displayName": "md5",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "file_name",
              "displayName": "file_name",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "link",
              "displayName": "link",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "table_name",
              "displayName": "table_name",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date_created",
              "displayName": "date_created",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1392,
        432
      ],
      "id": "fd499cf7-93fc-4e52-8204-33b92acbb7c4",
      "name": "RFP List Table Add",
      "credentials": {
        "postgres": {
          "id": "wK2pSCG9jTniRU28",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8eb22279-f4b8-478a-bbe0-ef2728e64b28",
              "name": "md5",
              "value": "={{ $('RFP List Table Add').item.json.md5 }}",
              "type": "string"
            },
            {
              "id": "462b72a2-7c70-4ec0-ac6a-dfd576489390",
              "name": "fileName",
              "value": "={{ $('RFP List Table Add').item.json.file_name }}",
              "type": "string"
            },
            {
              "id": "f9011592-cd98-4e1d-a533-a9b79a3c4ba2",
              "name": "sessionId",
              "value": "={{ $('RFP Upload Web New').item.json.body.sessionId }}",
              "type": "string"
            },
            {
              "id": "f79ed218-ec77-4cc5-8927-a56e792e9fea",
              "name": "date",
              "value": "={{ new Date().toLocaleString('sv-SE') }}",
              "type": "string"
            },
            {
              "id": "661a75f1-7709-4816-9da8-86059aa026d2",
              "name": "link",
              "value": "={{ $('fileLink').item.json.publicUrl }}",
              "type": "string"
            },
            {
              "id": "286389f2-3a3d-4b57-a756-37016609199c",
              "name": "indexName",
              "value": "={{ $('RFP List Table Add').item.json.table_name }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -976,
        432
      ],
      "id": "a8c598b5-dca5-4a0f-b7c9-7d4480ec70c5",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "jsCode": "const projectRef = 'wrdntxsgwastvpyxdnmq';\nconst filePath = $('Upload RFP to Supabase').first().json.Key; // 'rfps/rfp_dashboard_rfp_5b90.pdf'\n\nconst publicUrl = `https://${projectRef}.supabase.co/storage/v1/object/public/${filePath}`;\n\nreturn [{\n  json: {\n    publicUrl\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -992,
        192
      ],
      "id": "5de8a15f-8d6f-44d4-8ec3-54a664a9663e",
      "name": "fileLink"
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -720,
        176
      ],
      "id": "23e4f42f-dbf9-4348-8cfb-c2f95a4c1a40",
      "name": "Responds To Rest"
    },
    {
      "parameters": {
        "jsCode": "const sessionId = $input.first().json.sessionId;\n\nconst executionId = $execution.id;\nconst workflowId = $workflow.id;\nconst startTime = new Date().toISOString();\n\n// Create session data object\nconst sessionData = {\n  sessionId: sessionId,\n  executionId: executionId,\n  workflowId: workflowId,\n  workflowName: $workflow.name,\n  startTime: startTime,\n  status: 'active',\n  nodeCount: 1\n};\n\n// Prepare file content\nconst fileName = `session_${executionId}.json`;\nconst fileContent = JSON.stringify(sessionData, null, 2);\nconst filePath = `/tmp/${fileName}`;\n\nconsole.log(`üìÅ Creating session file: ${filePath}`);\nconsole.log(`üÜî Session ID: ${sessionId}`);\n\nreturn {\n  json: {\n    sessionId: sessionId,\n    executionId: executionId,\n    fileName: fileName,\n    filePath: filePath,\n    fileContent: fileContent,\n    sessionData: sessionData,\n    \n    // Include original input data\n    ...$input.first()?.json\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1376,
        1216
      ],
      "id": "cb722f87-9151-4c9e-8952-7e6565df9ebd",
      "name": "Get Session ID and prepare file data"
    },
    {
      "parameters": {
        "url": "={{ $('Get Session ID and prepare file data').item.json.link }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -976,
        1216
      ],
      "id": "8906ae39-4427-45a4-a293-40ca91cf3eaa",
      "name": "Download File"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.74:8878/parse/file",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer dev-key"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            },
            {
              "name": "optimize_pdf",
              "value": "true"
            },
            {
              "name": "enable_chunking",
              "value": "true"
            },
            {
              "name": "max_tokens_per_chunk",
              "value": "400"
            },
            {
              "name": "merge_peers",
              "value": "true"
            },
            {
              "name": "include_full_metadata",
              "value": "true"
            },
            {
              "name": "embedding_model",
              "value": "nomic-ai/nomic-embed-text-v1.5"
            },
            {
              "name": "serialize_tables",
              "value": "true"
            },
            {
              "name": "semantic_refinement",
              "value": "false"
            }
          ]
        },
        "options": {
          "response": {}
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -800,
        1008
      ],
      "id": "94dfcb44-fe2e-422e-b82c-151ac1a6dd58",
      "name": "Chunker Full"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.userPrompt }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.systemPrompt }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -992,
        1520
      ],
      "id": "1012946e-14b5-40e7-a20e-1c7c999b0624",
      "name": "Optimize Chunks"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const contextForPrompt = $json.text;\nconst contextForPrompt_id = $json.chunk_id;\nconst systemPrompt = `You are a metadata extraction specialist for RFP documents.\n\nYour task is to analyze document chunks and identify which topics they SUBSTANTIALLY discuss.\n\nCRITICAL RULES:\n1. Only assign topics that are CLEARLY and SUBSTANTIALLY present in the chunk\n2. A brief mention does NOT qualify - the chunk must meaningfully discuss the topic\n3. Most chunks should have 1-3 topics maximum\n4. When in doubt, DO NOT assign the topic\n5. Distinguish between RFP DOCUMENT information vs PROJECT information\n\nOutput valid JSON only, no explanations.`;\n\nconst userPrompt = `Analyze this chunk and identify which topics it SUBSTANTIALLY discusses.\n\nSELECTIVITY RULES:\n- Only assign a topic if the chunk contains MEANINGFUL information about it\n- Brief mentions or implied connections DO NOT count\n- Ask yourself: \"Could someone answer a specific question about this topic using ONLY this chunk?\"\n- If the answer is NO, don't assign that topic\n\nIMPORTANT DISTINCTION:\n- \"rfp_metadata\" = Information ABOUT the RFP document itself (submission process, deadlines, evaluation)\n- Other topics = Requirements/details about THE PROJECT to be built\n\nTOPIC DEFINITIONS:\n\nPROJECT-RELATED TOPICS (about the system/product to be built):\n\n\"project_context\" - ONLY if chunk explicitly discusses:\n  ‚úì WHY the project is needed (business problems, pain points)\n  ‚úì Current situation that needs improvement\n  ‚úì Strategic goals or business objectives\n  ‚úó NOT just because it mentions \"project\" or \"system\"\n\n\"platforms\" - ONLY if chunk explicitly names target platforms:\n  ‚úì Web, mobile (iOS/Android), desktop, backend, API, admin panel\n  ‚úó NOT just because it says \"application\" or \"website\"\n\n\"techstack\" - ONLY if chunk specifies actual technologies:\n  ‚úì Programming languages, frameworks, databases (React, Python, PostgreSQL)\n  ‚úó NOT just because it mentions \"technology\" or \"system\"\n\n\"greenfield\" - ONLY if chunk explicitly states:\n  ‚úì Building new from scratch OR modifying existing system\n  ‚úó NOT assumed - must be explicitly mentioned\n\n\"functional_requirements\" - ONLY if chunk describes what users/system can do:\n  ‚úì User features, workflows, capabilities, business logic\n  ‚úì System behavior, data processing, operations\n  ‚úì \"Users can X\", \"System generates Y\", \"Application allows Z\"\n\n\"non_functional_requirements\" - ONLY if chunk specifies performance/quality attributes:\n  ‚úì Performance metrics, security standards, scalability requirements\n  ‚úì Usability requirements, accessibility standards (WCAG)\n  ‚úó NOT functional features, even if security-related features\n\n\"integrations\" - ONLY if chunk names SPECIFIC third-party services:\n  ‚úì Named services: Stripe, SendGrid, Auth0, Salesforce, Google Maps\n  ‚úó NOT generic mentions like \"payment gateway\" or \"email service\"\n\n\"data_migration\" - ONLY if chunk discusses moving/importing existing data:\n  ‚úì Migrating from old systems, importing records, ETL processes\n  ‚úó NOT just database requirements or data storage\n\n\"regulatory_compliance\" - ONLY if chunk names SPECIFIC regulations:\n  ‚úì GDPR, HIPAA, SOC2, ISO standards, PCI-DSS, legal requirements\n  ‚úó NOT just \"secure\" or \"compliant\" without specifics\n\n\"delivery_details\" - ONLY if chunk discusses project timeline/phases:\n  ‚úì MVP scope, sprint plans, milestones, delivery dates, phased rollout\n  ‚úó NOT just deadline mentions without project phase details\n\n\"training_requirements\" - ONLY if chunk discusses training/documentation:\n  ‚úì User training, admin training, knowledge transfer, training materials\n  ‚úó NOT just \"documentation\" as a deliverable\n\n\"support_maintenance\" - ONLY if chunk discusses post-launch support:\n  ‚úì Warranty periods, SLAs, maintenance contracts, support expectations\n  ‚úó NOT just \"support\" mentioned casually\n\nRFP DOCUMENT TOPICS (about the RFP process itself):\n\n\"rfp_metadata\" - ONLY if chunk contains RFP administrative information:\n  ‚úì RFP reference number, submission deadlines, contact information\n  ‚úì Proposal format requirements, evaluation criteria, scoring weights\n  ‚úì Client/company name in RFP header context\n  ‚úó NOT project/product details\n\n---\n\nChunk to analyze:\n\"\"\"\n${contextForPrompt}\n\"\"\"\n\nChunk Id to pass on:\n\"\"\"\n${contextForPrompt_id}\n\"\"\"\n\n---\n\nEXAMPLE CLASSIFICATIONS:\n\nGood Examples (what to do):\n\nChunk: \"Users can create events with unique IDs. Each event is assigned a 12-character ID based on date and serial number.\"\nTopics: [\"functional_requirements\"]\nWhy: Describes system behavior and data structure - that's functional requirements only\n\nChunk: \"Our current spreadsheet system is error-prone and inefficient. We need a modern solution to reduce errors by 80%.\"\nTopics: [\"project_context\"]\nWhy: Explains current problems and business goals\n\nChunk: \"Must integrate with Stripe (payments) and SendGrid (emails)\"\nTopics: [\"integrations\"]\nWhy: Names specific third-party services\n\nChunk: \"The web app must work on iOS, Android, and modern browsers\"\nTopics: [\"platforms\"]\nWhy: Explicitly lists target platforms\n\nChunk: \"System must handle 10,000 concurrent users with <2s response time and 99.9% uptime\"\nTopics: [\"non_functional_requirements\"]\nWhy: Specifies performance and reliability metrics\n\nChunk: \"Must comply with GDPR and achieve SOC2 Type II certification\"\nTopics: [\"regulatory_compliance\"]\nWhy: Names specific compliance requirements\n\nChunk: \"Proposals due May 30, 2025 at 5pm to procurement@company.com. Include technical and cost proposals.\"\nTopics: [\"rfp_metadata\"]\nWhy: RFP submission instructions\n\nBad Examples (what to avoid):\n\nChunk: \"The system generates unique identifiers for tracking\"\nTopics: [] or [\"functional_requirements\"]\nNOT: [\"techstack\", \"platforms\", \"integrations\"]\nWhy: Only describes a feature - no tech, platform, or integration details\n\nChunk: \"Users must be able to securely login with password\"\nTopics: [\"functional_requirements\"]\nNOT: [\"non_functional_requirements\", \"security\"]\nWhy: Login is a functional feature. Security requirements would specify standards like \"must use bcrypt with 12 rounds\" or \"must support MFA\"\n\nChunk: \"The portal will be accessible online\"\nTopics: []\nNOT: [\"platforms\"]\nWhy: Too vague - \"online\" doesn't specify web vs mobile vs API\n\nCRITICAL: Be STRICT. When analyzing, ask yourself:\n1. Is this topic CLEARLY and SUBSTANTIALLY discussed? (not just implied)\n2. Could someone answer specific questions about this topic from this chunk alone?\n3. Is there actual INFORMATION here, or just a vague mention?\n\nIf you're unsure, DO NOT include the topic.\n\nOutput format (strict JSON):\n{\n  \"chunk_id\": \"chunk_id\",\n  \"chunk_text\": \"chunk\",\n  \"topics\": []\n}\n\nAnalyze the chunk now and return ONLY the JSON.`;\n\nreturn {\n  json: {\n    userPrompt,\n    systemPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        1520
      ],
      "id": "b5e9319f-5b42-4b19-a3eb-d5ad95e2132c",
      "name": "PreparePrompts - Metadata Enrichment"
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "={{ $('When Executed by Another Workflow').first().json.indexName }}",
          "mode": "name"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "embedding": "={{ $json.embedding }}",
            "chunk_id": "={{ $('Add Metadata to Original').item.json.chunk_id }}",
            "text": "={{ $('Add Metadata to Original').item.json.text }}",
            "section_title": "={{ $('Add Metadata to Original').item.json.section_title }}",
            "topics": "={{ $('Add Metadata to Original').item.json.metadata.topics }}",
            "full_metadata": "={{ $('Add Metadata to Original').item.json.full_metadata }}",
            "metadata": "={{ $('Add Metadata to Original').item.json.metadata }}"
          },
          "matchingColumns": [
            "chunk_id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "chunk_id",
              "displayName": "chunk_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "section_title",
              "displayName": "section_title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "text",
              "displayName": "text",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "topics",
              "displayName": "topics",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": false
            },
            {
              "id": "metadata",
              "displayName": "metadata",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": false
            },
            {
              "id": "full_metadata",
              "displayName": "full_metadata",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": false
            },
            {
              "id": "embedding",
              "displayName": "embedding",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false
            },
            {
              "id": "updated_at",
              "displayName": "updated_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1216,
        1216
      ],
      "id": "b1069e35-5a21-433b-a006-5e7d224bb5c6",
      "name": "Insert or update rows in a table",
      "credentials": {
        "postgres": {
          "id": "wK2pSCG9jTniRU28",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.all().map(item => item.json);\n\n// Normalize and test against known patterns\nfunction isTOC(title) {\n  if (!title || typeof title !== 'string') return false;\n\n  const normalized = title\n    .toLowerCase()\n    .replace(/[^a-z0-9]/g, ' ') // replace punctuation with space\n    .replace(/\\s+/g, ' ')       // collapse spaces\n    .trim();\n\n  const tocKeywords = [\n    'table of contents',\n    'table of content',\n    'contents',\n    'toc'\n  ];\n\n  return tocKeywords.some(keyword => normalized.includes(keyword));\n}\n\n// Filter out chunks where the title suggests it's TOC\nconst filtered = input.filter(chunk => {\n  const title = chunk.section_title || chunk.text || '';\n  return !isTOC(title);\n});\n\nreturn filtered.map(chunk => ({ json: chunk }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        1216
      ],
      "id": "7cf1e1ef-ff6c-433c-a164-e85b74286be8",
      "name": "Remove TOC1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "/**\n * Minimal, safe hygiene for embedding payloads.\n * - No manual JSON escaping\n * - Removes control chars (except \\n and \\t)\n * - Normalizes Unicode and whitespace\n * - Preserves existing indices\n */\n\nfunction normalizeText(s) {\n  if (!s) return \"\";\n  if (typeof s.normalize === \"function\") s = s.normalize(\"NFKC\"); // Unicode normalize\n  s = s.replace(/\\u00A0/g, ' ');                                  // NBSP -> space\n  s = s.replace(/[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F-\\u009F]/g, ' '); // rm control (keep \\t,\\n)\n  s = s.replace(/\\r\\n?/g, '\\n');                                   // CRLF -> LF\n  s = s.replace(/[ \\t]+/g, ' ');                                   // collapse spaces/tabs\n  s = s.replace(/\\n{3,}/g, '\\n\\n');                                // limit consecutive newlines\n  return s.trim();\n}\n\nconst items = $input.all();\nconst out = [];\n\nfor (const item of items) {\n  let chunks;\n  if (Array.isArray(item.json)) chunks = item.json;\n  else if (Array.isArray(item.json?.chunks)) chunks = item.json.chunks;\n  else chunks = [item.json];\n\n  const sanitized = chunks.map((c) => {\n    const copy = { ...c };\n    if (copy.text != null) copy.text = normalizeText(copy.text);\n    if (copy.text_to_embed != null) copy.text_to_embed = normalizeText(copy.text_to_embed);\n    if (copy.section_title != null) copy.section_title = normalizeText(copy.section_title);\n\n    // keep source-of-truth indices; don't invent new ones here\n    if (!copy.vector_metadata) copy.vector_metadata = {};\n    if (copy.chunk_index != null && copy.vector_metadata.chunk_index == null) {\n      copy.vector_metadata.chunk_index = copy.chunk_index;\n    }\n    return copy;\n  });\n\n  if (Array.isArray(item.json)) out.push({ json: sanitized });\n  else if (Array.isArray(item.json?.chunks)) out.push({ json: { ...item.json, chunks: sanitized } });\n  else out.push({ json: sanitized[0] });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        1216
      ],
      "id": "0a7cdc7f-26ed-43a9-800e-3b3634c68a20",
      "name": "Final Escaping1"
    },
    {
      "parameters": {
        "jsCode": "const slug = s => (s ?? \"\").toLowerCase()\n  .replace(/[^a-z0-9]+/g, '_')\n  .replace(/^_|_$/g, '')\n  .slice(0, 50);\n\nconst final = ($input.first()?.json?.data?.chunks ?? []).map((c, i) => {\n  const sectionTitle = c?.section_title ?? \"\";\n  const text = c?.text ?? \"\";\n  const chunkIndex = c?.chunk_index ?? \"\";\n\n  const chunkId = `${slug(sectionTitle)}_${i}`;\n  const metadata = {\n    ...(c?.metadata ?? {}),\n    chunk_index: chunkIndex\n  };\n  const full_metadata = c.full_metadata;\n\n  // Remove heading_path if it exists\n  //if (\"heading_path\" in metadata) {\n    //delete metadata.heading_path;\n // }\n\n  return {\n    section_title: sectionTitle,\n    chunk_id: chunkId,\n    text: text,\n    metadata: metadata,\n    full_metadata:full_metadata\n  };\n});\n\nreturn final.map(j => ({ json: j }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        1216
      ],
      "id": "37d039fd-d79e-4329-bea6-ff55d901a4df",
      "name": "Format Output1"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"chunk_id\": \"chunk_id\",\n  \"chunk_text\": \"chunk\",\n  \"topics\": []\n}",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -32,
        1696
      ],
      "id": "b195999c-e496-4e83-9f60-6f1eee8a1b76",
      "name": "Topics"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"chunk_id\": \"${contextForPromptChunkId}\",\n  \"needs_splitting\": true,\n  \"reason\": \"brief reason why splitting or why not\",\n  \"sub_chunks\": [\n    {\n      \"text\": \"sub-chunk content with preserved formatting and numbering\",\n      \"topic\": \"brief human-readable description of what this sub-chunk is about\"\n    }\n  ]\n}",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -896,
        1680
      ],
      "id": "46d16eba-c045-4f3c-b00f-7d6098d83d39",
      "name": "Subchunking"
    },
    {
      "parameters": {
        "jsCode": "// Assuming input is array of chunks\nconst chunks = $input.all().map(item => item.json);\n\n// Simple token estimation: ~4 characters per token (rough but fast)\nfunction estimateTokens(text) {\n  return Math.ceil(text.length / 4);\n}\n\n// Add token count to all chunks\nconst chunksWithTokens = chunks.map(chunk => ({\n  ...chunk,\n  estimated_tokens: estimateTokens(chunk.text)\n}));\n\n// Filter chunks that need splitting (>= 300 tokens)\nconst chunksNeedingSplitting = chunksWithTokens.filter(chunk => \n  chunk.estimated_tokens >= 300\n);\n\n// If there are chunks needing splitting, return them\nif (chunksNeedingSplitting.length > 0) {\n  return chunksNeedingSplitting.map(chunk => ({\n    json: chunk\n  }));\n}\n\n// Otherwise, find and return the biggest chunk\nconst biggestChunk = chunksWithTokens.reduce((max, chunk) => \n  chunk.estimated_tokens > max.estimated_tokens ? chunk : max\n);\n\nreturn [{\n  json: biggestChunk\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1376,
        1520
      ],
      "id": "1f99949e-64e0-40b8-a375-4e683cae2861",
      "name": "Only Big Chunks"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const contextForPromptText = $json.text;\nconst contextForPromptChunkId = $json.chunk_id;\nconst contextForPromptMetadata = $json.metadata;\n\nconst systemPrompt = `You are an RFP document chunking specialist optimizing chunks for semantic search.\n\nCORE RULES:\n1. Target: 200-350 tokens per sub-chunk\n2. Minimum: 100 tokens per sub-chunk (NEVER go below this)\n3. Maximum: 5 sub-chunks per original chunk\n4. Each sub-chunk must be independently understandable\n\nOutput valid JSON only.`;\n\nconst userPrompt = `Analyze this chunk and decide if it needs splitting.\n\n‚ö†Ô∏è MANDATORY SPLITTING CRITERIA (split if ANY apply):\n1. Chunk exceeds 500 tokens\n2. Contains 10+ numbered/bulleted items\n3. Mixes multiple distinct topics (e.g., technical requirements + RFP deadlines)\n4. Combines PROJECT requirements with RFP PROCESS information\n\nüìã HOW TO SPLIT LISTS:\n- For lists with 10+ items: Split into groups of 4-6 related items\n- Each group should be 200-350 tokens\n- Keep list context/header with first group\n- Preserve all numbering\n\nExample for 12-item list:\n‚úÖ Sub-chunk 1: \"Features 1-6: [inventory tracking, scanning, transfers, replenishment, picking, returns]\"\n‚úÖ Sub-chunk 2: \"Features 7-12: [traceability, cycle counting, mobile app, dashboard, reporting, user management]\"\n‚ùå Sub-chunk 1: \"All 12 features together\" (if >500 tokens)\n‚ùå Sub-chunk 1: \"Feature 1\" (too granular)\n\nüîí STRICT MINIMUM ENFORCEMENT:\n- If a sub-chunk would be <100 tokens, MERGE it with adjacent content\n- Single sentences MUST be merged, never standalone\n- Confidentiality notices, deadlines, Q&A info: merge together as \"RFP Process Details\"\n\n‚úÖ DO split:\n- Chunks >500 tokens\n- Lists >10 items\n- Mixed PROJECT + PROCESS content\n- Multiple distinct technical topics\n\n‚ùå DON'T split:\n- Chunks <400 tokens with single topic\n- Lists <10 items (unless >400 tokens total)\n- Cohesive narratives about one topic\n\n---\n\nChunk to analyze:\n\"\"\"\n${contextForPromptText}\n\"\"\"\n\nChunk ID: ${contextForPromptChunkId}\nMetadata: ${JSON.stringify(contextForPromptMetadata)}\n\n---\n\nOutput JSON:\n{\n  \"chunk_id\": \"${contextForPromptChunkId}\",\n  \"needs_splitting\": true/false,\n  \"reason\": \"why split or not - mention token count if relevant\",\n  \"sub_chunks\": [\n    {\n      \"text\": \"sub-chunk text with full context\",\n      \"topic\": \"brief description\"\n    }\n  ]\n}\n\nVALIDATION: Before submitting, verify:\n- If needs_splitting=true: created 2-5 sub-chunks, each 100+ tokens\n- If needs_splitting=false: original chunk is <500 tokens\n- No sub-chunk is <100 tokens`;\n\nreturn {\n  json: {\n    userPrompt,\n    systemPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1184,
        1520
      ],
      "id": "2fa36f0b-bfbc-437b-9459-6ac0e0ba2e36",
      "name": "PreparePrompts - subchunking"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "qwen3-coder-30b-32k",
          "mode": "list",
          "cachedResultName": "qwen3-coder-30b-32k"
        },
        "options": {
          "maxTokens": 6000,
          "responseFormat": "json_object",
          "temperature": 0,
          "topP": 0.9
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1376,
        1760
      ],
      "id": "9efb7d29-afda-4099-ada6-7c1a1fc0c44a",
      "name": "Qwen",
      "credentials": {
        "openAiApi": {
          "id": "09tIxrZPXx1gwPgx",
          "name": "vllm"
        }
      }
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -1104,
        1760
      ],
      "id": "43d61ec1-fe66-4fc6-bc36-1959d46dcbf1",
      "name": "Google Gemini - Free",
      "credentials": {
        "googlePalmApi": {
          "id": "TJ0yEUGcCyO1AqYW",
          "name": "Google Gemini - Free"
        }
      }
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -144,
        1808
      ],
      "id": "05f644c3-d69f-478f-8b7d-76ae5a0448ec",
      "name": "Google Gemini - Payed",
      "credentials": {
        "googlePalmApi": {
          "id": "Ix2j2Yr3QW5lFklE",
          "name": "Google Gemini - ZM"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.userPrompt }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.systemPrompt }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -96,
        1520
      ],
      "id": "a78e722a-bbc5-4aa8-be3d-cf3ef4a4fa46",
      "name": "Optimize Chunks - Metadata"
    },
    {
      "parameters": {
        "jsCode": "const originalChunks = $('Add topic to Text').all();\nconst llmResults = $input.all();\n\n// Create topics map\nconst topicsMap = new Map();\nllmResults.forEach(result => {\n  const output = result.json.output || result.json;\n  if (output.chunk_id && output.topics) {\n    topicsMap.set(output.chunk_id, output.topics);\n  }\n});\n\n// Merge topics into original chunks\nconst enrichedChunks = originalChunks.map(chunk => {\n  const topics = topicsMap.get(chunk.json.chunk_id);\n  \n  if (!topics) {\n    console.warn(`‚ö†Ô∏è  No topics found for chunk_id: ${chunk.json.chunk_id}`);\n  }\n  \n  return {\n    json: {\n      ...chunk.json,\n      metadata: {\n        ...chunk.json.metadata,\n        topics: topics || [] // Add topics to metadata\n      }\n    }\n  };\n});\n\n// Log statistics\nconst chunksWithTopics = enrichedChunks.filter(c => c.json.metadata.topics && c.json.metadata.topics.length > 0).length;\nconsole.log(`‚úÖ Enriched ${chunksWithTopics}/${enrichedChunks.length} chunks with topics`);\n\nreturn enrichedChunks;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        1216
      ],
      "id": "d1c8a0d9-0f07-4f65-b45e-550257a6cc77",
      "name": "Add Metadata to Original"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.70:11434/api/embed",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "nomic-embed-text:latest"
            },
            {
              "name": "input",
              "value": "={{ $('Prepare Embedding Text').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "id": "58cc09a4-7361-4282-8ece-664c1fceebb2",
      "name": "Embed Chunks1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        816,
        1216
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $json;\nreturn {\n  json: {\n    embedding: input.embeddings[0]\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        1216
      ],
      "id": "1f0c6670-81f4-4c43-8b1e-803ca3af1690",
      "name": "Embedding Isolated1"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "qS4XuYo2wZl1DdYR",
          "mode": "list",
          "cachedResultName": "Estimation Tool",
          "cachedResultUrl": "/projects/NM7VZoSXkcKo262s/datatables/qS4XuYo2wZl1DdYR"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "execution_id": "={{ $json.executionId }}",
            "session_id": "={{ $json.sessionId }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "execution_id",
              "displayName": "execution_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "optimizeBulk": false
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -1184,
        1216
      ],
      "id": "f3542a69-2270-4ca0-8a7e-ca6e4eb84d12",
      "name": "Add Execution id"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "qwen3-coder-30b-32k",
          "mode": "list",
          "cachedResultName": "qwen3-coder-30b-32k"
        },
        "options": {
          "maxTokens": 6000,
          "responseFormat": "json_object",
          "temperature": 0,
          "topP": 0.9
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1248,
        1760
      ],
      "id": "fc891713-d6dd-4c51-ac00-25be3b356785",
      "name": "Qwen1",
      "credentials": {
        "openAiApi": {
          "id": "09tIxrZPXx1gwPgx",
          "name": "vllm"
        }
      }
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -992,
        1824
      ],
      "id": "c3595819-cf34-4d26-b786-8cb1dc423c2d",
      "name": "Google Gemini - Payed1",
      "credentials": {
        "googlePalmApi": {
          "id": "Ix2j2Yr3QW5lFklE",
          "name": "Google Gemini - ZM"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const originalChunks = $('Final Escaping1').all().map(item => item.json);\nconst subchunkResults = $input.all().map(item => item.json);\n\n// Create a map of chunk_id -> sub_chunks\nconst subchunksMap = new Map();\nsubchunkResults.forEach(result => {\n  const output = result.output || result;\n  if (output.sub_chunks && output.sub_chunks.length > 0) {\n    subchunksMap.set(output.chunk_id, output.sub_chunks);\n  }\n});\n\n// Process each original chunk\nconst processedChunks = [];\n\noriginalChunks.forEach(chunk => {\n  const subchunks = subchunksMap.get(chunk.chunk_id);\n  \n  if (subchunks && subchunks.length > 1) {\n    // Has multiple sub-chunks, create separate entries for each\n    subchunks.forEach((subchunk, index) => {\n      processedChunks.push({\n        section_title: chunk.section_title,\n        chunk_id: `${chunk.chunk_id}_sub${index + 1}`,\n        text: subchunk.text,\n        metadata: {\n          ...chunk.metadata,\n          parent_chunk_id: chunk.chunk_id,\n          subchunk_index: index + 1,\n          total_subchunks: subchunks.length,\n          subchunk_topic: subchunk.topic\n        },\n        full_metadata: chunk.full_metadata\n      });\n    });\n  } else if (subchunks && subchunks.length === 1) {\n    // Single sub-chunk (no split), keep original but update text if different\n    processedChunks.push({\n      ...chunk,\n      text: subchunks[0].text,\n      metadata: {\n        ...chunk.metadata,\n        subchunk_topic: subchunks[0].topic,\n        was_subchunked: false\n      }\n    });\n  } else {\n    // No sub-chunks found (shouldn't happen, but handle it)\n    processedChunks.push({\n      ...chunk,\n      metadata: {\n        ...chunk.metadata,\n        was_subchunked: false\n      }\n    });\n  }\n});\n\n// Log statistics\nconst originalCount = originalChunks.length;\nconst processedCount = processedChunks.length;\nconsole.log(`‚úÖ Processed ${originalCount} original chunks into ${processedCount} final chunks`);\nconsole.log(`üìä Expansion ratio: ${(processedCount / originalCount).toFixed(2)}x`);\n\nreturn processedChunks.map(chunk => ({ json: chunk }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -704,
        1520
      ],
      "id": "77fcf308-1f77-45af-9865-bda5c90a2ec9",
      "name": "Merge with original chunks"
    },
    {
      "parameters": {
        "jsCode": "const allChunks = $input.all().map(item => item.json);\n\n// Filter to only subchunked chunks (those with _sub in chunk_id)\nconst subchunkedOnly = allChunks.filter(chunk => {\n  return chunk.chunk_id.includes('_sub') || \n         chunk.metadata?.parent_chunk_id ||\n         chunk.metadata?.total_subchunks > 1;\n});\n\n// Group by parent for easier viewing\nconst groupedByParent = {};\nsubchunkedOnly.forEach(chunk => {\n  const parentId = chunk.metadata?.parent_chunk_id || chunk.chunk_id.replace(/_sub\\d+$/, '');\n  \n  if (!groupedByParent[parentId]) {\n    groupedByParent[parentId] = {\n      parent_id: parentId,\n      total_subchunks: chunk.metadata?.total_subchunks || 0,\n      subchunks: []\n    };\n  }\n  \n  groupedByParent[parentId].subchunks.push({\n    chunk_id: chunk.chunk_id,\n    subchunk_index: chunk.metadata?.subchunk_index,\n    topic: chunk.metadata?.subchunk_topic,\n    text_preview: chunk.text,\n    text_length: chunk.text.length,\n    estimated_tokens: Math.ceil(chunk.text.length / 4)\n  });\n});\n\n// Convert to array and sort\nconst grouped = Object.values(groupedByParent).map(group => {\n  group.subchunks.sort((a, b) => a.subchunk_index - b.subchunk_index);\n  return group;\n});\n\n// Statistics\nconst stats = {\n  total_chunks: allChunks.length,\n  subchunked_chunks: subchunkedOnly.length,\n  parent_chunks_split: grouped.length,\n  chunks_not_split: allChunks.length - subchunkedOnly.length,\n  expansion_ratio: (subchunkedOnly.length / grouped.length).toFixed(2)\n};\n\nconsole.log('üìä Subchunking Statistics:');\nconsole.log(`   Total chunks: ${stats.total_chunks}`);\nconsole.log(`   Chunks that were split: ${stats.parent_chunks_split}`);\nconsole.log(`   Resulting subchunks: ${stats.subchunked_chunks}`);\nconsole.log(`   Chunks NOT split: ${stats.chunks_not_split}`);\nconsole.log(`   Avg subchunks per parent: ${stats.expansion_ratio}x`);\n\nconsole.log('\\nüîç Subchunked Chunks by Parent:');\ngrouped.forEach(group => {\n  console.log(`\\nüì¶ Parent: ${group.parent_id} (${group.total_subchunks} subchunks)`);\n  group.subchunks.forEach(sub => {\n    console.log(`   ‚îî‚îÄ ${sub.chunk_id}`);\n    console.log(`      Topic: ${sub.topic}`);\n    console.log(`      Tokens: ~${sub.estimated_tokens}`);\n    console.log(`      Preview: ${sub.text_preview}`);\n  });\n});\n\n// Return grouped structure for further processing\nreturn grouped.map(group => ({ json: group }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        1712
      ],
      "id": "f221748e-b2c6-4bb8-9764-93fe2bd3f138",
      "name": "Only subchunked"
    },
    {
      "parameters": {
        "jsCode": "// Add subchunk_topic to text if it exists\nconst chunks = $input.all().map(item => item.json);\n\nconst enrichedChunks = chunks.map(chunk => {\n  // Check if subchunk_topic exists in metadata\n  const subchunkTopic = chunk.metadata?.subchunk_topic;\n  \n  if (subchunkTopic) {\n    // Prepend topic as a header to the text\n    chunk.text = `## ${subchunkTopic}\\n\\n${chunk.text}`;\n  }\n  \n  return chunk;\n});\n\nreturn enrichedChunks.map(chunk => ({ json: chunk }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -544,
        1520
      ],
      "id": "3dc54cfc-f4f3-415a-9669-eef06bd96656",
      "name": "Add topic to Text"
    },
    {
      "parameters": {
        "jsCode": "const chunks = $input.all().map(item => item.json);\n\nconst cleanedChunks = chunks.map(chunk => {\n  // Remove \"search_document:\" or \"search_documents:\" prefix (case insensitive)\n  chunk.text = chunk.text.replace(/^search_documents?:\\s*/i, '');\n  \n  return chunk;\n});\n\nreturn cleanedChunks.map(chunk => ({ json: chunk }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        1216
      ],
      "id": "8dd24e8f-41e6-479e-bd4d-aa48062504ad",
      "name": "Remove Search Documents prefix"
    },
    {
      "parameters": {
        "jsCode": "const chunks = $input.all().map(item => item.json);\n\nconst prefixedChunks = chunks.map(chunk => {\n  // Only add prefix if it doesn't already exist\n  if (!chunk.text.match(/^search_documents?:\\s*/i)) {\n    chunk.text = `search_document: ${chunk.text}`;\n  }\n  \n  return chunk.text;\n});\n\nreturn prefixedChunks.map(text => ({ json: { text } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        1216
      ],
      "id": "abf471e9-3f23-47a1-9931-8bc6b90f3696",
      "name": "Prepare Embedding Text"
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "sessionId"
            },
            {
              "name": "md5"
            },
            {
              "name": "fileName"
            },
            {
              "name": "date"
            },
            {
              "name": "link"
            },
            {
              "name": "indexName"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1744,
        1216
      ],
      "id": "2b4f4c1e-0f0f-4651-a21e-20eb80af6635",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.74:8879/api/parse-and-chunk",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer dev-key"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            },
            {
              "name": "optimize_pdf",
              "value": "false"
            },
            {
              "name": "enable_chunking",
              "value": "true"
            },
            {
              "name": "max_tokens_per_chunk",
              "value": "768"
            },
            {
              "name": "merge_peers",
              "value": "true"
            },
            {
              "name": "include_full_metadata",
              "value": "false"
            },
            {
              "name": "embedding_model",
              "value": "nomic-ai/nomic-embed-text-v1.5"
            },
            {
              "name": "serialize_tables",
              "value": "true"
            }
          ]
        },
        "options": {
          "response": {}
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -800,
        704
      ],
      "id": "454e68d0-4e41-4745-a50e-c6b46fa73417",
      "name": "Chunker VLM"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const contextForPromptText = $json.text;\nconst contextForPromptChunkId = $json.chunk_id;\n\nconst systemPrompt = `You are a document chunking optimization specialist. Your task is to analyze document chunks and split them into smaller, semantically coherent sub-chunks when needed for optimal RAG retrieval.\n\nRules:\n1. Split chunks that contain multiple distinct topics, concepts, or document sections\n2. Each sub-chunk should focus on ONE clear topic or section\n3. Target 150-500 tokens per sub-chunk for optimal embedding\n4. Preserve complete original text - no content loss\n5. Keep naturally cohesive paragraphs together\n6. Each sub-chunk must be independently understandable\n7. Pass on the original chunk_id\n\nOutput valid JSON only, no explanations.`;\n\n// 3. Define the user prompt\nconst userPrompt = `Analyze this chunk and determine if it should be split into smaller, focused sub-chunks for better semantic retrieval.\n\nSplit criteria:\n- Multiple distinct topics/sections\n- Mixed content types (narrative + tables/lists)\n- Topic shifts within the text\n- Size exceeds ~500 tokens\nFor sections with multiple feature categories (bulleted lists with subsections), consider splitting by logical feature groupings if the section exceeds 250 tokens.\n\nOriginal chunk:\n${contextForPromptText}\n---------\nOriginal chunk_id:\n${contextForPromptChunkId}\n---------\nIf no splitting needed, return single sub-chunk with original text. \n\nThis must be json ouput structure:\n\n{\n  \"chunk\": \"original_chunk\",\n  \"chunk_id\": \"chunk_id\",\n  \"needs_splitting\": true,\n  \"reason\": \"brief reason if splitting\",\n  \"sub_chunks\": [\n    {\n      \"sub_chunk_id\": 1,\n      \"text\": \"sub-chunk content\",\n      \"topic\": \"brief topic description\"\n    }\n  ]\n}\n`;\n\nreturn {\n  json: {\n    userPrompt,\n    systemPrompt: systemPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        848
      ],
      "id": "8802dc5c-f854-4112-b816-a1d2399c14a9",
      "name": "PreparePrompts - subchunking2"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const contextForPrompt = $json.text;\n\nconst systemPrompt = `You are an RFP metadata extraction specialist.\n\nAnalyze chunks and identify topics they SUBSTANTIALLY discuss (not just mention).\n\nRules:\n- Only assign topics with CLEAR, MEANINGFUL information\n- Most chunks = 1-3 topics max\n- When unsure, DO NOT assign\n- Distinguish: RFP document info vs. project requirements\n\nOutput valid JSON only.`;\n\nconst userPrompt = `Identify topics this chunk SUBSTANTIALLY discusses.\n\nSELECTIVITY: Only assign if chunk answers specific questions about that topic. Brief mentions don't count.\n\nTOPICS:\n\nPROJECT (about system being built):\n- project_context - WHY project needed, business goals, current problems\n- platforms - Explicit platforms: web/mobile/desktop/API (not just \"app\")\n- techstack - Specific tech: React/Python/PostgreSQL (not just \"technology\")\n- greenfield - Explicitly states new vs. existing system modification\n- functional_requirements - What system/users DO: features, workflows, capabilities\n- non_functional_requirements - HOW system performs: performance metrics, security standards, scalability\n- integrations - Named services: Stripe/SendGrid/Auth0 (not generic \"payment gateway\")\n- data_migration - Moving/importing existing data, ETL\n- regulatory_compliance - Named regulations: GDPR/HIPAA/SOC2\n- delivery_details - Timeline, MVP, sprints, milestones, phases\n- training_requirements - User training, documentation, knowledge transfer\n- support_maintenance - Post-launch support, warranty, SLAs\n\nRFP DOCUMENT (about RFP process):\n- rfp_metadata - Deadlines, contact info, evaluation criteria, submission format\n\nChunk:\n\"\"\"\n${contextForPrompt}\n\"\"\"\n\nExamples:\n\n‚úì \"Users create events with 12-char IDs (date+serial+system code)\"\n‚Üí {\"topics\": [\"functional_requirements\"]}\n(Describes system behavior only)\n\n‚úì \"Current spreadsheet system error-prone, need 80% error reduction\"\n‚Üí {\"topics\": [\"project_context\"]}\n\n‚úì \"Integrate Stripe (payments) & SendGrid (email)\"\n‚Üí {\"topics\": [\"integrations\"]}\n\n‚úì \"iOS, Android, web browsers\"\n‚Üí {\"topics\": [\"platforms\"]}\n\n‚úì \"10K concurrent users, <2s response, 99.9% uptime\"\n‚Üí {\"topics\": [\"non_functional_requirements\"]}\n\n‚úì \"Comply with GDPR and SOC2 Type II\"\n‚Üí {\"topics\": [\"regulatory_compliance\"]}\n\n‚úì \"Proposals due May 30 to contact@company.com\"\n‚Üí {\"topics\": [\"rfp_metadata\"]}\n\n‚úó \"System generates unique identifiers\"\n‚Üí {\"topics\": [\"functional_requirements\"]}\nNOT: techstack, platforms (no tech/platform mentioned)\n\n‚úó \"Users securely login with password\"\n‚Üí {\"topics\": [\"functional_requirements\"]}\nNOT: non_functional_requirements (login is a feature, not performance/security metric)\n\n‚úó \"Portal accessible online\"\n‚Üí {\"topics\": []}\n(Too vague - not enough detail for any topic)\n\nValidation questions:\n1. Is topic CLEARLY discussed (not implied)?\n2. Can someone answer questions about it from this chunk?\n3. Actual information present (not vague mention)?\n\nIf unsure ‚Üí DON'T assign.\n\nOutput JSON only:\n{\"topics\": []}`;\n\nreturn {\n  json: {\n    userPrompt,\n    systemPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        848
      ],
      "id": "b256f37e-5a46-4fca-877c-bff006c5b1bd",
      "name": "PreparePrompts - Metadata - short"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1600,
        1216
      ],
      "id": "b9564583-cd85-47fd-8d62-aaa47524c38b",
      "name": "Edit Fields1"
    },
    {
      "parameters": {
        "operation": "deleteRows",
        "dataTableId": {
          "__rl": true,
          "value": "qS4XuYo2wZl1DdYR",
          "mode": "list",
          "cachedResultName": "Estimation Tool",
          "cachedResultUrl": "/projects/NM7VZoSXkcKo262s/datatables/qS4XuYo2wZl1DdYR"
        },
        "filters": {
          "conditions": [
            {
              "keyName": "execution_id",
              "keyValue": "={{ $('Get Session ID and prepare file data').first().json.executionId }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1408,
        1216
      ],
      "id": "7ade1c2e-820f-42e9-b4a9-876cc3d172e3",
      "name": "Delete row(s)"
    },
    {
      "parameters": {
        "url": "={{ $('Get Session ID and prepare file data').item.json.link }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -992,
        1040
      ],
      "id": "a25ab266-caaa-4ea6-a6bd-c17aaec1578d",
      "name": "Download File1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.74:8878/parse/file",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer dev-key"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            },
            {
              "name": "optimize_pdf",
              "value": "false"
            },
            {
              "name": "enable_chunking",
              "value": "true"
            },
            {
              "name": "max_tokens_per_chunk",
              "value": "500"
            },
            {
              "name": "merge_peers",
              "value": "true"
            },
            {
              "name": "include_full_metadata",
              "value": "true"
            },
            {
              "name": "embedding_model",
              "value": "nomic-ai/nomic-embed-text-v1.5"
            },
            {
              "name": "serialize_tables",
              "value": "true"
            },
            {
              "name": "semantic_refinement",
              "value": "false"
            },
            {
              "name": "parse_images",
              "value": "true"
            },
            {
              "name": "image_description_prompt",
              "value": "Describe the image using only objective, visible details in a single paragraph. Include all text, labels, numbers, titles, and annotations. Mention charts, diagrams, tables, shapes, colors, components, and any arrows or connections exactly as shown. Focus on entities and their relationships, positions, and structure. Do not interpret meaning or intent‚Äîonly describe what is explicitly visible. Output must be detailed enough for embedding and retrieval in RFP analysis. Under 400 tokens."
            }
          ]
        },
        "options": {
          "response": {}
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -784,
        1216
      ],
      "id": "01532c60-9451-401c-8cf4-ad39eae78720",
      "name": "Chunker Full1"
    }
  ],
  "pinData": {},
  "repo_name": "n8n-backup-zm",
  "repo_owner": "zlatkomq",
  "repo_path": "",
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "052VdzVIz9bFK2dw"
  },
  "shared": [
    {
      "updatedAt": "2025-10-20T12:49:28.945Z",
      "createdAt": "2025-10-20T12:49:28.945Z",
      "role": "workflow:owner",
      "workflowId": "aKpGZQLxTLr3FkPY",
      "projectId": "NM7VZoSXkcKo262s"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 2,
  "updatedAt": "2025-11-19T13:42:45.638Z",
  "versionId": "cf596d11-d19a-461d-8af4-f0a185154ab4"
}