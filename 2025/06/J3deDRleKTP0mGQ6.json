{
  "active": true,
  "connections": {
    "RFP Upload": {
      "main": [
        []
      ]
    },
    "Delete Index": {
      "main": [
        [
          {
            "node": "Create ES Url",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create ES Url",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embed Chunks": {
      "main": [
        [
          {
            "node": "Embedding Isolated",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove TOC": {
      "main": [
        [
          {
            "node": "Filter Empty & Duplicate Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Escaping": {
      "main": [
        [
          {
            "node": "Embed Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Empty & Duplicate Chunks": {
      "main": [
        [
          {
            "node": "Split Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Chunks": {
      "main": [
        [
          {
            "node": "Final Escaping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Add To Index",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embedding Isolated": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker Full": {
      "main": [
        [
          {
            "node": "Format Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Output": {
      "main": [
        [
          {
            "node": "Remove TOC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload RFP to Google Drive": {
      "main": [
        [
          {
            "node": "Crate Index Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RFP Upload Web": {
      "main": [
        [
          {
            "node": "Upload RFP to Google Drive",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MD5": {
      "main": [
        [
          {
            "node": "Search For File in Sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If already exists": {
      "main": [
        [
          {
            "node": "Modify file entry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add file entry": {
      "main": [
        [
          {
            "node": "Respond to File Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search For File in Sheet": {
      "main": [
        [
          {
            "node": "If already exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start RFP Analysis": {
      "main": [
        [
          {
            "node": "Extract FileId",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Crate Index Name": {
      "main": [
        [
          {
            "node": "Add file entry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create ES Url": {
      "main": [
        [
          {
            "node": "Create index - Elastic Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create index - Elastic Search": {
      "main": [
        [
          {
            "node": "Download File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download File": {
      "main": [
        [
          {
            "node": "Chunker Full",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract FileId": {
      "main": [
        [
          {
            "node": "Delete Index",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add To Index": {
      "main": [
        [
          {
            "node": "SSE - Document Preparation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Replace text in a presentation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-06-18T08:56:39.210Z",
  "id": "J3deDRleKTP0mGQ6",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "RFP Analysis Public - Ingestion",
  "nodes": [
    {
      "parameters": {
        "formTitle": "RFP",
        "formFields": {
          "values": [
            {
              "fieldLabel": "file",
              "fieldType": "file",
              "multipleFiles": false,
              "acceptFileTypes": ".pdf"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        2000,
        1280
      ],
      "id": "27e6a927-47cf-4769-a3a3-7bde84bc1b92",
      "name": "RFP Upload",
      "webhookId": "c13ee4fc-516b-4741-ad7c-121c51c3f594",
      "disabled": true
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.elasticsearchUrl }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "elasticsearchApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"mappings\": {\n    \"dynamic\": \"strict\",\n    \"properties\": {\n      \"chunk_id\": {\n        \"type\": \"keyword\"\n      },\n      \"section_title\": {\n        \"type\": \"text\",\n        \"fields\": {\n          \"keyword\": { \"type\": \"keyword\" }\n        }\n      },\n      \"text\": {\n        \"type\": \"text\",\n        \"analyzer\": \"standard\"\n      },\n      \"metadata\": {\n        \"type\": \"object\",\n        \"dynamic\": \"strict\",\n        \"properties\": {\n          \"content_type\": { \"type\": \"keyword\" },\n          \"pages\":        { \"type\": \"integer\" },\n          \"chunk_index\":  { \"type\": \"integer\" }\n        }\n      },\n      \"embeddings\": {\n        \"type\":       \"dense_vector\",\n        \"dims\":       768,\n        \"index\":      true,\n        \"similarity\": \"cosine\"\n      }\n    }\n  }\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1312,
        1120
      ],
      "id": "afb4882a-6253-4218-a3e6-376835c29c58",
      "name": "Create index - Elastic Search",
      "credentials": {
        "elasticsearchApi": {
          "id": "wwaILZtoajWrVXwt",
          "name": "Elasticsearch account"
        }
      }
    },
    {
      "parameters": {
        "resource": "index",
        "operation": "delete",
        "indexId": "={{ $('Start RFP Analysis').item.json.body.indexName }}"
      },
      "type": "n8n-nodes-base.elasticsearch",
      "typeVersion": 1,
      "position": [
        1312,
        928
      ],
      "id": "142d1a96-25da-484f-a0c1-f551596c4c4f",
      "name": "Delete Index",
      "alwaysOutputData": false,
      "credentials": {
        "elasticsearchApi": {
          "id": "wwaILZtoajWrVXwt",
          "name": "Elasticsearch account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.70:11434/api/embed",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"nomic-embed-text:latest\",\n  \"input\": [\"{{ $input.item.json.text}}\"]\n}",
        "options": {}
      },
      "id": "0552d36a-7aba-4059-b87e-34706df537e9",
      "name": "Embed Chunks",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2912,
        1072
      ]
    },
    {
      "parameters": {
        "jsCode": "const input = $input.all().map(item => item.json);\n\n// Normalize and test against known patterns\nfunction isTOC(title) {\n  if (!title || typeof title !== 'string') return false;\n\n  const normalized = title\n    .toLowerCase()\n    .replace(/[^a-z0-9]/g, ' ') // replace punctuation with space\n    .replace(/\\s+/g, ' ')       // collapse spaces\n    .trim();\n\n  const tocKeywords = [\n    'table of contents',\n    'table of content',\n    'contents',\n    'toc'\n  ];\n\n  return tocKeywords.some(keyword => normalized.includes(keyword));\n}\n\n// Filter out chunks where the title suggests it's TOC\nconst filtered = input.filter(chunk => {\n  const title = chunk.section_title || chunk.text || '';\n  return !isTOC(title);\n});\n\nreturn filtered.map(chunk => ({ json: chunk }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        928
      ],
      "id": "efe28274-ee4a-49ea-93d4-c1114f51fc3a",
      "name": "Remove TOC"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Sanitizes chunk text to ensure compatibility with Nomic embedding API\n * This function deals with \"smart\" characters, quotes, and other problematic elements\n * Preserves existing chunk_index values\n * \n * @returns {Array} - The processed items\n */\nfunction sanitizeChunksForEmbedding() {\n  // Get input data\n  const items = $input.all();\n  const outputItems = [];\n  \n  // Process each item\n  for (const item of items) {\n    // Handle different possible input formats\n    let chunks;\n    \n    if (Array.isArray(item.json)) {\n      // If item.json is already an array of chunks\n      chunks = item.json;\n    } else if (item.json.chunks && Array.isArray(item.json.chunks)) {\n      // If chunks are in a property called 'chunks'\n      chunks = item.json.chunks;\n    } else {\n      // If the item itself is a single chunk\n      chunks = [item.json];\n    }\n    \n    // Track chunk indices per section for chunks without existing chunk_index\n    const sectionIndices = {};\n    \n    // Sanitize each chunk\n    const sanitizedChunks = chunks.map(chunk => {\n      // Create a new object to avoid modifying the original\n      const sanitizedChunk = { ...chunk };\n      \n      // Sanitize the main text field if it exists\n      if (sanitizedChunk.text) {\n        sanitizedChunk.text = sanitizeText(sanitizedChunk.text);\n      }\n      \n      // Sanitize the embedding text field if it exists\n      if (sanitizedChunk.text_to_embed) {\n        sanitizedChunk.text_to_embed = sanitizeText(sanitizedChunk.text_to_embed);\n      }\n      \n      // Sanitize section title if it exists\n      if (sanitizedChunk.section_title) {\n        sanitizedChunk.section_title = sanitizeText(sanitizedChunk.section_title);\n      }\n      \n      // Ensure vector_metadata exists\n      if (!sanitizedChunk.vector_metadata) {\n        sanitizedChunk.vector_metadata = {};\n      }\n      \n      // IMPORTANT CHANGE: Only set chunk_index if it doesn't already exist\n      if (sanitizedChunk.vector_metadata.chunk_index === undefined) {\n        // Initialize or get the current section's index tracker\n        const sectionKey = sanitizedChunk.section_title || 'default';\n        if (sectionIndices[sectionKey] === undefined) {\n          sectionIndices[sectionKey] = 0;\n        }\n        \n        // Populate chunk_index in vector_metadata\n        sanitizedChunk.vector_metadata.chunk_index = sectionIndices[sectionKey];\n        \n        // If this is a split chunk and already has part_index, don't increment the section index\n        // Otherwise, increment for the next chunk with the same section\n        if (!sanitizedChunk.vector_metadata.is_split || \n            (sanitizedChunk.vector_metadata.is_split && sanitizedChunk.vector_metadata.part_index === 0)) {\n          sectionIndices[sectionKey]++;\n        }\n      }\n      \n      return sanitizedChunk;\n    });\n    \n    // Return in the same format as received\n    if (Array.isArray(item.json)) {\n      outputItems.push({ json: sanitizedChunks });\n    } else if (item.json.chunks && Array.isArray(item.json.chunks)) {\n      outputItems.push({\n        json: {\n          ...item.json,\n          chunks: sanitizedChunks\n        }\n      });\n    } else {\n      // Return processed single chunk\n      outputItems.push({ json: sanitizedChunks[0] });\n    }\n  }\n  \n  return outputItems;\n}\n\n/**\n * Sanitizes text by replacing special characters and ensuring JSON compatibility\n * @param {string} text - Text to sanitize\n * @returns {string} - Sanitized text\n */\nfunction sanitizeText(text) {\n  if (!text) return '';\n  \n  // Remove wrapping quotes if present\n  let sanitized = text;\n  if ((text.startsWith('\"') && text.endsWith('\"')) || \n      (text.startsWith('\"') && text.endsWith('\"'))) {\n    sanitized = text.substring(1, text.length - 1);\n  }\n  \n // Replace smart/curly quotes with straight quotes\n  sanitized = sanitized\n    .replace(/[\\u2018\\u2019]/g, \"'\") // Replace single smart quotes\n    .replace(/[\\u201C\\u201D]/g, '\"') // Replace double smart quotes\n    \n    // Remove invisible control characters\n    .replace(/[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200F\\u2028-\\u202F]/g, ' ')\n    \n    // Replace other problematic characters\n    .replace(/[\\u2013\\u2014]/g, '-') // Replace em dash and en dash\n    .replace(/\\u2026/g, '...') // Replace ellipsis\n    .replace(/\\u00A0/g, ' ') // Replace non-breaking space\n    \n    // Special handling for bullet points and other list markers\n    .replace(/[\\u2022\\u2023\\u25E6\\u2043\\u2219]/g, '*') // Convert bullets to asterisks\n    \n    // Normalize whitespace (remove multiple spaces, tabs, etc.)\n    .replace(/\\s+/g, ' ')\n    // Trim leading and trailing whitespace\n    .replace(/\"/g, '\\\\\"')\n    // Handle other special characters that might cause issues in JSON\n    //.replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\f/g, '\\\\f')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r')\n    .replace(/\\t/g, '\\\\t')\n    .trim();\n  \n  return sanitized;\n}\n\n// Execute the function and return the result\nreturn sanitizeChunksForEmbedding();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        1088
      ],
      "id": "16c62415-7376-462d-a0c8-41cd12c09c6d",
      "name": "Final Escaping"
    },
    {
      "parameters": {
        "operation": "create",
        "indexId": "={{ $('Start RFP Analysis').item.json.body.indexName }}",
        "dataToSend": "autoMapInputData",
        "inputsToIgnore": "=",
        "additionalFields": {},
        "options": {}
      },
      "type": "n8n-nodes-base.elasticsearch",
      "typeVersion": 1,
      "position": [
        3424,
        1072
      ],
      "id": "761a7bb5-0706-4525-a84a-394c4ffabced",
      "name": "Add To Index",
      "credentials": {
        "elasticsearchApi": {
          "id": "wwaILZtoajWrVXwt",
          "name": "Elasticsearch account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node\n// Filters out empty / duplicate chunks and adds an incremental `index` starting at 0.\n\nfunction filterEmptyAndDuplicateChunks() {\n  const inputItems   = $input.all();\n  const seenContent  = new Set();\n  const validChunks  = [];\n\n  for (const item of inputItems) {\n    const chunk = item.json;\n\n    /* 1 ── skip empty rows */\n    if (!chunk || !chunk.text || chunk.text.trim() === \"\") continue;\n\n    const titleText   = (chunk.section_title || \"\").trim();\n    const contentText = chunk.text.trim();\n\n    /* 2 ── drop title-only rows */\n    if (contentText === titleText) continue;\n\n    /* 3 ── duplicate detection (normalise whitespace + leading numbers) */\n    const normalized = contentText\n      .replace(/^\\d+(\\.\\d+)*\\s+/gm, \"\")  // remove numbered prefixes\n      .replace(/\\s+/g, \" \")              // collapse whitespace\n      .trim();\n\n    if (seenContent.has(normalized)) continue;\n    seenContent.add(normalized);\n\n    validChunks.push(chunk);\n  }\n\n  /* 4 ── return with incremental index */\n  return validChunks.map((chunk, idx) => ({\n    json: {\n      ...chunk\n    }\n  }));\n}\n\nreturn filterEmptyAndDuplicateChunks();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        928
      ],
      "id": "cf43bac4-a43d-4872-8f94-8b89b4054655",
      "name": "Filter Empty & Duplicate Chunks"
    },
    {
      "parameters": {
        "jsCode": "/**\n * N8n Function node to split document chunks for optimized Elasticsearch vector search\n * Takes chunks like those extracted from PDF documents and splits them if they exceed token limits\n * while preserving context and section structure\n * \n * @param {Object} items - The input items coming from n8n workflow\n * @returns {Object} - The processed items with optimized chunks for vector search\n */\n\n// Main processing function for n8n Function node\nfunction processDocumentChunks() {\n  // Get input data\n  const items = $input.all();\n  \n  // Configuration (could be made into node parameters in a custom n8n node)\n  const maxTokens = 7000;        // Maximum tokens per chunk\n  const overlapTokens = 50;     // Tokens to overlap between chunks\n  const embeddingField = 'text_to_embed'; // Field for the text to be embedded\n  \n  let outputItems = [];\n  let globalChunkIndex = 0;  // Global counter for chunk indexing\n  \n  // Process each item\n  for (const item of items) {\n    let inputChunks;\n    \n    // Determine input format\n    if (Array.isArray(item.json)) {\n      // If input is already an array of chunks\n      inputChunks = item.json;\n    } else if (item.json.chunks && Array.isArray(item.json.chunks)) {\n      // If chunks are in a property called 'chunks'\n      inputChunks = item.json.chunks;\n    } else {\n      // If the item itself is a single chunk\n      inputChunks = [item.json];\n    }\n    \n    // Process the chunks\n    const processedChunks = splitChunks(inputChunks, maxTokens, overlapTokens, embeddingField, globalChunkIndex);\n    \n    // Update the counter\n    globalChunkIndex += inputChunks.length;\n    \n    // Return in the same format as received\n    if (Array.isArray(item.json)) {\n      outputItems.push({ json: processedChunks });\n    } else if (item.json.chunks) {\n      outputItems.push({\n        json: {\n          ...item.json,\n          chunks: processedChunks\n        }\n      });\n    } else {\n      // Return processed chunks as separate items\n      processedChunks.forEach(chunk => {\n        outputItems.push({ json: chunk });\n      });\n    }\n  }\n  \n  return outputItems;\n}\n\n/**\n * Split chunks if they exceed the token limit\n * @param {Array} chunks - Array of document chunks\n * @param {number} maxTokens - Maximum tokens per chunk\n * @param {number} overlapTokens - Tokens to overlap between chunks\n * @param {string} embeddingField - Field name for embeddings\n * @param {number} startIndex - Starting index for global chunk indexing\n * @returns {Array} - Processed chunks\n */\nfunction splitChunks(chunks, maxTokens, overlapTokens, embeddingField, startIndex = 0) {\n  const result = [];\n  \n  // Process each chunk\n  chunks.forEach((chunk, index) => {\n    const tokenCount = estimateTokens(chunk.text);\n    const actualIndex = startIndex + index;\n    \n    // If chunk is within token limit, add vector fields and keep it as is\n    if (tokenCount <= maxTokens) {\n      result.push({\n        ...chunk,\n        //[embeddingField]: chunk.text, // Add embedding field\n        // vector_metadata: {\n        //   token_count: tokenCount,\n        //   is_split: false,\n        // }\n      });\n      return;\n    }\n    \n    // Need to split the chunk - first try by paragraphs\n    const paragraphs = splitIntoParagraphs(chunk.text);\n    let chunkParts = [];\n    \n    if (paragraphs.length > 1) {\n      // If we have multiple paragraphs, try to group them into chunks\n      chunkParts = groupContentUnits(paragraphs, maxTokens, chunk.section_title);\n    } else {\n      // Otherwise split by sentences\n      const sentences = splitIntoSentences(chunk.text);\n      chunkParts = groupContentUnits(sentences, maxTokens, chunk.section_title);\n    }\n    \n    // Create chunk objects for each part\n    chunkParts.forEach((part, partIndex) => {\n      // Add section title to beginning of parts after the first one\n      const textWithContext = partIndex === 0 \n        ? part\n        : `${chunk.section_title || ''} (continued) ${part}`;\n      \n      result.push({\n        chunk_id: `${chunk.chunk_id}_part${partIndex + 1}`,\n        section_title: chunk.section_title,\n        text: textWithContext,\n        //[embeddingField]: textWithContext, // Field for embedding\n        metadata: {\n          ...chunk.metadata,\n          parent_chunk_id: chunk.chunk_id,\n          is_split_chunk: true,\n          split_part: partIndex + 1,\n          total_parts: chunkParts.length\n        },\n        //vector_metadata: {\n         // token_count: estimateTokens(textWithContext),\n         // is_split: true,\n         // part_index: partIndex\n       // }\n      });\n    });\n  });\n  \n  return result;\n}\n\n/**\n * Group content units (paragraphs or sentences) into chunks of appropriate size\n * @param {Array} units - Content units to group\n * @param {number} maxTokens - Maximum tokens per chunk\n * @param {string} sectionTitle - Section title for context\n * @returns {Array} - Grouped content as chunks\n */\nfunction groupContentUnits(units, maxTokens, sectionTitle) {\n  const chunks = [];\n  let currentChunk = '';\n  let currentTokens = 0;\n  const contextPrefix = sectionTitle ? sectionTitle + ' ' : '';\n  const contextTokens = estimateTokens(contextPrefix);\n  \n  // Account for context in parts after the first\n  const effectiveMaxTokens = maxTokens - contextTokens;\n  \n  units.forEach((unit, index) => {\n    const unitTokens = estimateTokens(unit);\n    \n    // If this unit alone exceeds limits, split it further by words\n    if (unitTokens > effectiveMaxTokens) {\n      if (currentChunk) {\n        chunks.push(currentChunk);\n        currentChunk = '';\n        currentTokens = 0;\n      }\n      \n      // Split large unit by words\n      const words = unit.split(/\\s+/);\n      let tempChunk = '';\n      \n      words.forEach(word => {\n        const wordTokens = estimateTokens(word + ' ');\n        \n        if (currentTokens + wordTokens > effectiveMaxTokens) {\n          if (tempChunk) {\n            chunks.push(tempChunk);\n            tempChunk = word;\n            currentTokens = wordTokens;\n          } else {\n            // Word itself is too big, have to include it anyway\n            tempChunk = word;\n            currentTokens = wordTokens;\n          }\n        } else {\n          tempChunk += (tempChunk ? ' ' : '') + word;\n          currentTokens += wordTokens;\n        }\n      });\n      \n      if (tempChunk) {\n        chunks.push(tempChunk);\n      }\n    }\n    // If adding this unit would exceed max tokens, start a new chunk\n    else if (currentTokens + unitTokens > effectiveMaxTokens) {\n      if (currentChunk) {\n        chunks.push(currentChunk);\n      }\n      currentChunk = unit;\n      currentTokens = unitTokens;\n    } \n    // Add to current chunk\n    else {\n      currentChunk += (currentChunk ? ' ' : '') + unit;\n      currentTokens += unitTokens;\n    }\n  });\n  \n  // Add any remaining content\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n  \n  return chunks;\n}\n\n/**\n * Split text into paragraphs\n * @param {string} text - Input text\n * @returns {Array} - Array of paragraphs\n */\nfunction splitIntoParagraphs(text) {\n  // Split on double newlines or equivalent\n  return text.split(/\\n\\s*\\n|\\r\\n\\s*\\r\\n/).filter(p => p.trim());\n}\n\n/**\n * Split text into sentences\n * @param {string} text - Input text\n * @returns {Array} - Array of sentences\n */\nfunction splitIntoSentences(text) {\n  // Split on sentence-ending punctuation followed by space or end of string\n  return text.split(/(?<=[.!?])\\s+|(?<=[.!?])$/).filter(s => s.trim());\n}\n\n/**\n * Estimate token count for a text string\n * @param {string} text - Text to estimate tokens for\n * @returns {number} - Estimated token count\n */\nfunction estimateTokens(text) {\n  if (!text) return 0;\n  \n  // Simple estimation: roughly 4 characters per token for English\n  // For production, replace with a proper tokenizer matching your embedding model\n  return Math.ceil(text.length / 4);\n}\n\n// Execute the function and return results\nreturn processDocumentChunks();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2304,
        1088
      ],
      "id": "bfd53af7-dc60-4e89-9843-130b5f07c4cc",
      "name": "Split Chunks"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ab2bedcf-f824-47dd-9e51-00888ee470fa",
              "name": "chunk_id",
              "value": "={{ $('Final Escaping').item.json.chunk_id }}",
              "type": "string"
            },
            {
              "id": "3ad9ad67-06cb-4490-b5c0-d87362a48128",
              "name": "section_title",
              "value": "={{ $('Final Escaping').item.json.section_title }}",
              "type": "string"
            },
            {
              "id": "16c251d1-42c5-45a4-978e-ce91f0e295bb",
              "name": "text",
              "value": "={{ $('Final Escaping').item.json.text }}",
              "type": "string"
            },
            {
              "id": "53121648-9acf-46fb-9027-7898e85865d5",
              "name": "metadata",
              "value": "={{ $('Final Escaping').item.json.metadata }}",
              "type": "object"
            },
            {
              "id": "4f420c43-5c17-474f-b524-9f7a98f9873a",
              "name": "embeddings",
              "value": "={{ $json.embedding }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3264,
        1072
      ],
      "id": "1eb28ad7-9fca-4f1d-818a-f470aaeb62a4",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $json;\nreturn {\n  json: {\n    embedding: input.embeddings[0]\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3088,
        1072
      ],
      "id": "6bcfa2f7-37db-425e-90bc-41162cdffdd1",
      "name": "Embedding Isolated"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.20.70:8878/parse/file",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer dev-key"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "data",
              "value": "{\"chunk_document\":true,\"max_tokens_per_chunk\":7000,\"optimize_pdf\":true}"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2000,
        1024
      ],
      "id": "fc89653c-6f03-414e-9d00-570108a7057a",
      "name": "Chunker Full"
    },
    {
      "parameters": {
        "jsCode": "const slug = s => (s ?? \"\").toLowerCase()\n  .replace(/[^a-z0-9]+/g, '_')\n  .replace(/^_|_$/g, '')\n  .slice(0, 50);\n\nconst final = ($input.first()?.json?.data?.chunks ?? []).map((c, i) => {\n  const sectionTitle = c?.section_title ?? \"\";\n  const text = c?.text ?? \"\";\n  const chunkIndex = c?.chunk_index ?? \"\";\n\n  const chunkId = `${slug(sectionTitle)}_${i}`;\n  const metadata = {\n    ...(c?.metadata ?? {}),\n    chunk_index: chunkIndex\n  };\n\n  // Remove heading_path if it exists\n  if (\"heading_path\" in metadata) {\n    delete metadata.heading_path;\n  }\n\n  return {\n    section_title: sectionTitle,\n    chunk_id: chunkId,\n    text: text,\n    metadata: metadata\n  };\n});\n\nreturn final.map(j => ({ json: j }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2304,
        928
      ],
      "id": "50856c24-2785-435c-9c42-28e7851402ea",
      "name": "Format Output"
    },
    {
      "parameters": {
        "content": "## Generating JSON with chunks from raw PDF\n\n### Using Chunker on docker.",
        "height": 380,
        "width": 300,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1920,
        848
      ],
      "id": "8fbb74d4-6e06-440f-892e-d6fddae2574f",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "## JSON Cleanup & Splitting",
        "height": 380,
        "width": 620
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2224,
        848
      ],
      "id": "b6f8cbde-7d6b-4052-9529-437648ee4b3b",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "content": "## Remove and recreate the index\n",
        "height": 460,
        "width": 680,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1248,
        848
      ],
      "id": "c5deb0eb-ec8a-4360-9407-fdd87b4f243d",
      "name": "Sticky Note18"
    },
    {
      "parameters": {
        "inputDataFieldName": "file",
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "value": "1C7AyLSHO26Q49PKK0lDXD3adR50ha8NA",
          "mode": "list",
          "cachedResultName": "Uploaded RFPs",
          "cachedResultUrl": "https://drive.google.com/drive/folders/1C7AyLSHO26Q49PKK0lDXD3adR50ha8NA"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1008,
        144
      ],
      "id": "f2b2453d-5b2a-404a-8b82-e292129b3dff",
      "name": "Upload RFP to Google Drive",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "OYJ2pu0fWBya0IA6",
          "name": "Google Drive account 3"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rfp-upload",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        720,
        144
      ],
      "id": "fd39d181-e35a-454a-9383-978f991743e2",
      "name": "RFP Upload Web",
      "webhookId": "663a2e7d-35dd-4241-8890-97393732bb42"
    },
    {
      "parameters": {
        "binaryData": true,
        "binaryPropertyName": "file"
      },
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        720,
        368
      ],
      "id": "c9f2e849-3119-4c04-9edd-2a1e2b8ee782",
      "name": "MD5",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9a436325-f8ac-491f-99aa-c66f916b471d",
              "leftValue": "={{$json.Filename === undefined}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1104,
        368
      ],
      "id": "1f8a125f-d7f2-456d-b6a9-8e8d37240092",
      "name": "If already exists",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og",
          "mode": "list",
          "cachedResultName": "List Of RFPs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "RFPs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "md5": "={{ $json.md5Checksum }}",
            "fileName": "={{ $json.name }}",
            "sessionId": "={{ $('RFP Upload Web').item.json.body.sessionId }}",
            "date": "={{ new Date().toLocaleString('sv-SE') }}",
            "link": "={{ $json.webContentLink }}",
            "indexName": "={{ $json.indexName }}"
          },
          "matchingColumns": [
            "md5"
          ],
          "schema": [
            {
              "id": "fileName",
              "displayName": "fileName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "sessionId",
              "displayName": "sessionId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "date",
              "displayName": "date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "link",
              "displayName": "link",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "md5",
              "displayName": "md5",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "indexName",
              "displayName": "indexName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        1440,
        144
      ],
      "id": "efe8e7a0-f552-4ed8-b9a7-e903af600c89",
      "name": "Add file entry",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "FtlTep04mtONOydH",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og",
          "mode": "list",
          "cachedResultName": "List Of RFPs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "RFPs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "SessionId": "={{ $('RFP Upload Web').item.json.body.sessionId }}",
            "Date": "={{ new Date().toLocaleString('sv-SE') }}",
            "md5": "={{ $json.md5 }}"
          },
          "matchingColumns": [
            "md5"
          ],
          "schema": [
            {
              "id": "Filename",
              "displayName": "Filename",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "SessionId",
              "displayName": "SessionId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Date",
              "displayName": "Date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Link",
              "displayName": "Link",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "md5",
              "displayName": "md5",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        1328,
        352
      ],
      "id": "e6df858e-5bcc-4ab3-baf6-53502857cacd",
      "name": "Modify file entry",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "FtlTep04mtONOydH",
          "name": "Google Sheets account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og",
          "mode": "list",
          "cachedResultName": "List Of RFPs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "RFPs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1e8eRVEvcmnDiQ9tpS_DdfhbnDvWXz-m2R5Y9P41U9og/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "md5",
              "lookupValue": "={{ $json.md5 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        928,
        368
      ],
      "id": "1b1daa6f-a87f-427f-8184-650927d41b64",
      "name": "Search For File in Sheet",
      "alwaysOutputData": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "FtlTep04mtONOydH",
          "name": "Google Sheets account"
        }
      },
      "disabled": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        1680,
        144
      ],
      "id": "7788000d-2d77-4317-8684-e16b8e87bfb5",
      "name": "Respond to File Upload"
    },
    {
      "parameters": {
        "content": "## RFP Upload to Google Drive",
        "height": 500,
        "width": 1340
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        592,
        48
      ],
      "id": "b019217c-5b77-4c16-b4bc-92da74816432",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rfp-analyse",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        752,
        928
      ],
      "id": "3e087f09-a1e9-4a21-9ea2-bb5ac59cf165",
      "name": "Start RFP Analysis",
      "webhookId": "663a2e7d-35dd-4241-8890-97393732bb42"
    },
    {
      "parameters": {
        "jsCode": "const fileName = items[0].json.name.toLowerCase()\n  .replace('.pdf', '')\n  .replace(/[^a-z0-9]/g, '-');\nconst indexName = `rfp-${fileName}-${items[0].json.md5Checksum.substring(0, 8)}`;\n\nreturn [{\n  json: {\n    ...items[0].json,\n    indexName: indexName // rfp-tps-8e7b748d\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        144
      ],
      "id": "d4a8f4f8-f053-477c-9cab-1307cbcb85fb",
      "name": "Crate Index Name"
    },
    {
      "parameters": {
        "jsCode": "const indexName = $('Start RFP Analysis').first().json.body.indexName;\nif (!indexName) {\n  throw new Error('indexName not found in previous step');\n}\n\nconst elasticUrl = `http://192.168.20.70:9204/${indexName}`;\n\nreturn [{\n  json: {\n    ...items[0].json,\n    elasticsearchUrl: elasticUrl,\n    elasticEndpoint: `${elasticUrl}/_doc`  // For document operations\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1664,
        928
      ],
      "id": "ce98e640-e01e-4233-9b4b-05de43ce1592",
      "name": "Create ES Url"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $('Extract FileId').item.json.googleFileId }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1504,
        1504
      ],
      "id": "07211692-7dd6-4388-b6fe-ccba6070586e",
      "name": "Download File",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "OYJ2pu0fWBya0IA6",
          "name": "Google Drive account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract file ID from the link\nconst link = items[0].json.body.link;\n\n// This regex handles multiple Google Drive URL formats:\n// - https://drive.google.com/uc?id=FILE_ID&export=download\n// - https://drive.google.com/file/d/FILE_ID/view\n// - https://drive.google.com/open?id=FILE_ID\nconst match = link.match(/[?&]id=([a-zA-Z0-9_-]+)|\\/d\\/([a-zA-Z0-9_-]+)/);\nconst fileId = match ? (match[1] || match[2]) : null;\n\nif (!fileId) {\n  throw new Error('Could not extract file ID from link');\n}\n\nreturn [{\n  json: {\n    ...items[0].json.body,\n    googleFileId: fileId  // Will be: 1zkYxLnRpA-NeMAWeT-vzTO6rkl6G4ae7\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        928
      ],
      "id": "648ea675-cc7c-4930-b310-ce5820383f18",
      "name": "Extract FileId"
    },
    {
      "parameters": {
        "content": "## Download file\n from GoogleDrive\n",
        "height": 380,
        "width": 680,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1248,
        1344
      ],
      "id": "067ac3b8-7d03-40bd-ac50-2bc054d532e8",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://sse-estimation-tool.onrender.com/progress",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"step\": \"document_preparation\",\n  \"title\": \"Step 1: Document Preparation\", \n  \"output\": \"✅ **Document Successfully Processed**\\n**Next Step:** Project information extraction will begin automatically.\",\n  \"sessionId\": \"{{ $('Start RFP Analysis').item.json.body.sessionId }}\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3648,
        1072
      ],
      "id": "af80cda3-14a9-4a51-aa37-2ccbb5d7017d",
      "name": "SSE - Document Preparation"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        2272,
        208
      ],
      "id": "f9b7bb9f-074a-4422-bf63-b81bc8b03708",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "operation": "replaceText",
        "presentationId": "1p4sm-9e1G0F21DYyaGgeNPp0GaSzaTylWZz0ZyS78N4",
        "textUi": {
          "textValues": [
            {
              "pageObjectIds": [
                "g2cdde7dbd32_0_1584"
              ],
              "text": "testing",
              "replaceText": "bla"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSlides",
      "typeVersion": 2,
      "position": [
        2592,
        192
      ],
      "id": "89242fb7-4bf1-4dc9-b071-25469cafe45b",
      "name": "Replace text in a presentation",
      "credentials": {
        "googleSlidesOAuth2Api": {
          "id": "MGYKLk02BvihRKyy",
          "name": "Google Slides account"
        }
      }
    }
  ],
  "pinData": {},
  "repo_name": "n8n-backup-zm",
  "repo_owner": "zlatkomq",
  "repo_path": "",
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "shared": [
    {
      "createdAt": "2025-06-18T08:56:39.210Z",
      "updatedAt": "2025-06-18T08:56:39.210Z",
      "role": "workflow:owner",
      "workflowId": "J3deDRleKTP0mGQ6",
      "projectId": "NM7VZoSXkcKo262s"
    }
  ],
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-04-24T10:59:44.979Z",
      "updatedAt": "2025-04-24T10:59:44.979Z",
      "id": "qEREEA2JvunvA9Nv",
      "name": "Estimation Tool"
    }
  ],
  "triggerCount": 2,
  "updatedAt": "2025-08-27T11:13:08.162Z",
  "versionId": "91dbf8d7-c305-46fd-955b-e93a222f6216"
}